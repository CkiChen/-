八股文

[toc]

# 操作系统

**操作系统是一组管理计算机软软硬件资源、以方便用户使用计算机的软件集合**。所以，怎么管理计算机软硬件资源就是操作系统的核心。

操作系统管理计算机软硬件资源，是将物理资源抽象成虚拟资源，以达到时分复用或空分复用的目的。所以，**操作系统管理资源的核心点有三个：抽象、虚拟和复用（时分复用和空分复用）。**

CSAPP中几个重要的抽象：

- 进程：抽象了处理器、内存和IO设备，都是将物理资源抽象成虚拟资源，然后时分复用和空分复用，对于处理器而言，分时系统本质就是时分复用，硬件多线程（或超线程）处理器就能做到空分复用；虚拟内存和文件就不用赘述了。
- 虚拟内存：抽象了主存和IO设备；
- 文件：抽象了IO设备；

### 1.虚拟

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，**地址空间的页并不需要全部在物理内存中**，当使用到一个没有在物理内存的页时，执行**页面置换算法**，将该页置换到内存中。



### 2.虚拟内存

#### 什么是虚拟内存？

从OS来看，虚拟内存是这样一种技术，“将物理内存抽象成虚拟内存，以空分复用和时分复用的方式让每个运行中的进程认为自己独占并且拥有连续可用的内存”。

#### 虚拟内存主要解决的两个痛点：

连续内存：通过虚拟地址空间，让进程在虚拟地址上连续，虚拟地址映射到的物理地址可以不连续；
全部加载：部分加载技术，让进程在虚拟地址上全部加载，但是虚拟地址映射的物理地址等到实际使用的时候才通过**缺页异常**来分配物理内存；

> 虚拟内存的目的是为了让**物理内存扩充成更大的逻辑内存**，从而让程序获得更多的可用内存。
>
> **为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。**这些页被映射到物理内存，但**不需要映射到连续的物理内存**，**也不需要所有页都必须在物理内存中**。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。
>
> 从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。

### 3.操作系统基本功能

#### 1. 进程管理

进程控制、进程同步、进程通信、死锁处理、处理机调度等。

#### 2. 内存管理

内存分配、地址映射、内存保护与共享、虚拟内存等。

#### 3. 文件管理

文件存储空间的管理、目录管理、文件读写管理和保护等。

#### 4. 设备管理

完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。

主要包括缓冲管理、设备分配、设备处理、虛拟设备等。



### 4.进程与线程

进程是资源分配的最小单位，线程是资源调度的最小单位。

一个进程中可以有多个线程，它们共享进程资源。

QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

#### 区别

Ⅰ 拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，**线程可以访问隶属进程的资源。**

Ⅱ 调度

**线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。**

Ⅲ 系统开销

由于**创建或撤销进程时**，**系统都要为之分配或回收资源，如内存空间、I/O 设备等**，所付出的**开销远大于创建或撤销线程时的开销**。类似地，在进行**进程切换**时，涉及当前**执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置**，而线程切换时只需保存和设置少量寄存器内容，开销很小。

Ⅳ 通信方面

线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

![image-20210911212035693](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210911212035693.png)

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。



### 5. 进程同步 

- #### **1.临界区** 

  > 对临界资源就行访问的那段代码称为临界区。 为了互斥访问临界资源，每个进程在进入临界区之前，需要先就行检查。

- #### **2.同步与互斥**

  > - **同步**：**多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。**
  > - 互斥：多个进程在同一时刻只有一个进程能进入临界区。

- #### **3.信号量**

> 信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。
>
> - **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
> - **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。
>
> down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。
>
> 如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。

**使用信号量实现生产者-消费者问题**

注意先检查empty和full 再上锁否则会出现死锁。

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，**而管程把控制的代码独立出来**，不仅不容易出错，也使得客户端代码调用更容易。

- #### **4.管程**

> 管程有一个重要特性：**在一个时刻只能有一个进程使用管程。**进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。
>
> 管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。



### 6.进程通信

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

#### **1.管道**

> pipe  只支持半双工协议，且只能在父子进程或者兄弟进程中使用

![image-20210911215815074](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210911215815074.png)

#### **2.FIFO 也叫命名管道**

> 去除管道只能在父子进程中使用的限制，全双工

#### 3.消息队列

> 相比于 FIFO，消息队列具有以下优点：
>
> - 消息队列可以**独立于读写进程存在**，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
> - **避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法**；
> - 读进程可以根据消息类型**有选择地接收消息**，而不像 FIFO 那样只能默认地接收

#### 4.信号量

> 它是一个计数器，用于为多个进程提供对共享数据对象的访问。

#### 5.共享存储

> 允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。需要使用信号量用来同步对共享存储的访问。

#### 6.套接字

> 与其它通信机制不同的是，它可用于不同机器间的进程通信。

### 7.内存管理——分页系统地址映射

内存管理单元（MMU）管理着地址空间和物理内存的转换，**其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表**。

一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。

### 8.页面置换算法

> 在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。
>
> 页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。
>
> **页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。**

#### 1.最佳 (理论上)

> **所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。**

#### 最近最久未使用（LRU）

> 为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。

#### FIFO 先进先出  

> 选择换出的页面是最先进入的页面。

#### 第二次机会算法

> FIFO可能将经常使用的页面置换出去，改进：当页面被访问（读或写）时设置该页面的R位为1.需要替换的时候，检查老页面的R，若为0，置换; 若为1，置为0,将该页面置到链表的尾端，修改装入时间，像刚装入一样。

### 9.分段 && 段页式

> 虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。**编译器在编译过程中建立的多个表，有 4 个表是动态增长的**，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。

分段的做法是**把每个表分成段**，**一个段构成一个独立的地址空间**。每个段的长度可以不同，并且可以动态增长。

**程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。**

#### 分页与分段的比较

- 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
- 地址空间的维度：分页是一维地址空间，分段是二维的。
- 大小是否可以改变：页的大小不可变，段的大小可以动态改变。
- 出现的原因：**分页主要用于实现虚拟内存，从而获得更大的地址空间**；**分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。**



### 死锁

#### 1.必要条件

- 互斥：每个资源要么**已经分配**给了一个进程，要么就是**可用**的。
- 占有和等待：**已经得到了某个资源的进程可以再请求新的资源。**
- 不可抢占：已经分配给一个进程的资源**不能强制性地被抢占**，**它只能被占有它的进程显式地释放**。
- 环路等待：有两个或者两个以上的进程组成**一条环路**，该环路中的**每个进程都在等待下一个进程所占有的资源。**

#### 2.处理方法

- 鸵鸟策略    因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。  **遇到了，忽略它**
- 死锁检测与死锁恢复
- 死锁预防
- 死锁避免

#### 3.死锁检测与死锁恢复

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

恢复

> - 利用**抢占**恢复
> - 利用**回滚**恢复
> - 通过杀死进程恢复

#### 4.死锁预防

##### 1. 破坏互斥条件

例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

##### 2. 破坏占有和等待条件

一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

##### 3. 破坏不可抢占条件

##### 4. 破坏环路等待

给资源统一编号，进程只能按编号顺序来请求资源。

#### 5.死锁避免   

> 1 安全状态
>
> 定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。
>
> ![image-20210912151317403](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912151317403.png)
>
> 按B\C\A的顺序去执行
>
> 2 银行家算法
>
> ![image-20210912151453358](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912151453358.png)
>
> 一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，**算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。**

























