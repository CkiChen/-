[toc]

# C++ 优秀面试题收集

#### 1.  fun(Null) 可能有哪几种结果

```c++
// file.h 中 有class Foo
void fun(Foo* ptr)
{
    ptr->bar();
}
fun(NULL);

#### 
```

- 静态方法可以被NULL调用

解释：

原因就是，这里调用的方法是类中声明的静态方法，也就是类方法，类方法是属于类的。通常使用类作为调用者来调用类方法，但我们也可以使用对象来调用类方法，其效果与通过类调用完全一样。当使用实例来调用类方法时，实际上依然是委托给该类来访问类成员，因此即使某个实例为null，它也可以访问它所属类的的类成员，而不发生空指针异常。

- 如果bar里面没有用到this指针的内容，也能调用成功，如果用到了调用失败
- 如果bar是个虚函数，需要通过this来找这个虚函数表，会错误

#### 2. 删除容器中的空格

```c++
str.erase(remove_if(str.begin(), str.end(), isspace), str.end());

//remove_if 的代码实现
template<typename T, typename P>
T remove_if(T beg, T end, P pred)
{
    T dest = beg;
    for (T itr = beg;itr != end; ++itr)
        if (!pred(*itr))
            *(dest++) = *itr;
    return dest;
}

//法二
std::string::iterator end_pos = std::remove(str.begin(), str.end(), ' ');
str.erase(end_pos, str.end());
```

#### 3. size_t  无符号整数

auto it = vec.size();

it 的类型是 size_t 无符号整数，    auto it = vec.size() - 1;   it >=0; it --;  会陷入死循环，因为无符号0 - 1 等于 0 + （-1） 有符号数 无符号数一起运算，会提升类型，变有符号为 无符号， 0+（-1）的补码  （即 1 的补码  11111111111111（看几位））为大正数；

> 1、字符串长度较小，且有和带符号int混用的需求，则可以赋值给int或 long int等
>
> 2、字符串长度大，且所用变量不会出现负值，则直接用size_type类型变量

#### 4.[【C++ STL】迭代器失效的几种情况总结](https://www.cnblogs.com/linuxAndMcu/p/14621819.html)

迭代器的失效问题：对容器的操作影响了元素的存放位置，称为迭代器失效。

**失效情况：**

- 当容器调用`erase()`方法后，当前位置到容器末尾元素的所有迭代器全部失效。
- 当容器调用`insert()`方法后，当前位置到容器末尾元素的所有迭代器全部失效。
- 如果容器扩容，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了。
- 不同容器的迭代器，是不能进行比较运算的。

对于序列式容器：

> 解决方法是利用`erase`方法可以返回下一个有效的 iterator，所以代码做如下修改即可：
>
> it=q.erase(it); // 这里会返回指向下一个元素的迭代器，因此不需要再自加了  代码手动自加
>
> 迭代器失效的原因是：因为 vetor、deque 使用了连续分配的内存，`erase`操作删除一个元素导致后面所有的元素都会向前移动一个位置，这些元素的地址发生了变化，所以当前位置到容器末尾元素的所有迭代器全部失效。

对于链表式容器：

> 对于链表式容器(如 list)，删除当前的 iterator，仅仅会使当前的 iterator 失效，这是因为 list 之类的容器，使用了链表来实现，插入、删除一个结点不会对其他结点造成影响。只要在 erase 时，递增当前 iterator 即可，并且 erase 方法可以返回下一个有效的 iterator。
>
> cont.erase(iter++); 就行

对于关联式容器：

> 对于关联容器(如 map, set,multimap,multiset)，删除当前的 iterator，仅仅会使当前的 iterator 失效，只要在 erase 时，递增当前 iterator 即可。这是因为 map 之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响。**erase 迭代器只是被删元素的迭代器失效，但是返回值为 void**，所以要采用`erase(iter++)`的方式删除迭代器。

解析：`dataMap.erase(iter++);`这句话分三步走，先把 iter 传值到 erase 里面，然后 iter 自增，然后执行 erase，所以 iter 在失效前已经自增了。

#### 5.C++ 智能指针剖析

- 如果ps有一个析构函数，该析构函数将在ps过期时自动释放它指向的内存。但ps的问题在于，它只是一个常规指针，不是有析构凼数的类对象指针。如果它指向的是对象，则可以在对象过期时，让它的析构函数删除指向的内存。

  这正是 auto_ptr、unique_ptr和shared_ptr这几个智能指针背后的设计思想。我简单的总结下就是：**将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。**

##### 为什么要使用智能指针：

智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。 所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

- #### 为什么摒弃auto_ptr？

> ```C++
> auto_ptr< string> ps (new string ("I reigned lonely as a cloud.”）;
> auto_ptr<string> vocation; 
> vocaticn = ps;  //对于auto_ptr来说，所有权完成转让，ps变成空指针（存在内存崩溃问题）
> //对于unique_ptr 来说，此这是不允许的 报错
> ```
>
> 上述赋值语句将完成什么工作呢？如果ps和vocation是常规指针，则两个指针将指向同一个string对象。这是不能接受的，因为程序将试图删除同一个对象两次——一次是ps过期时，另一次是vocation过期时。要避免这种问题，方法有多种：
>
> - 定义陚值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本，缺点是浪费空间，所以智能指针都未采用此方案。
> - 建立所有权（ownership）概念。对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的构造函数会删除该对象。然后让赋值操作转让所有权。这就是用于auto_ptr和unique_ptr 的策略，**但unique_ptr的策略更严格**。（**保证同一时间只有一个智能指针可以指向该对象**）
> - 创建智能更高的指针，**跟踪引用特定对象的智能指针数**。这称为引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1,。当减为0时才调用delete。这是shared_ptr采用的策略。
>
> 当然，同样的策略也适用于复制构造函数。
> 每种方法都有其用途，但为何说要摒弃auto_ptr呢？**避免潜在的内存崩溃问题**
>
> ` pwin = films[2]; // films[2] loses ownership. 将所有权从films[2]转让给pwin，此时films[2]不再引用该字符串从而变成空指针`
>
> films[2]已经是空指针了，下面输出访问空指针当然会崩溃了。但这里如果把auto_ptr换成shared_ptr或unique_ptr后，程序就不会崩溃，原因如下：
>
> - 使用shared_ptr时运行正常，因为shared_ptr采用**引用计数**，pwin和films[2]都指向同一块内存，在释放空间时因为事先要判断引用计数值的大小因此不会出现多次删除一个对象的错误。
> - 使用unique_ptr时编译出错，与auto_ptr一样，unique_ptr也采用所有权模型，但在使用unique_ptr时，程序不会等到运行阶段崩溃，而在编译器因下述代码行出现错误：

**总之，党程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做**

```C++
unique_ptr<string> pu1(new string ("hello world"));
unique_ptr<string> pu2;
pu2 = pu1;                                      // #1 not allowed
unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string ("You"));   // #2 allowed
```

- **shared_ptr**

- shared_ptr实现**共享式拥有**概念。**多个智能指针可以指向相同对象**，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。

  shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。

  - **weak_ptr**

  **weak_ptr 是一种不控制对象生命周期的智能指针**, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, **它的构造和析构不会引起引用记数的增加或减少**。**weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。**（循环引用：两个对象互相使用一个shared_ptr成员变量指向对方的会造成循环引用。导致引用计数失效。）它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。

#### 6.shared_ptr是如何实现的？

1. 构造函数中计数初始化为1；
2. 拷贝构造函数中计数值加1；
3. 赋值运算符中，左边的对象引用计数减1，右边的对象引用计数加1；（这是因为左侧的指针指向了右侧指针所指向的对象，因此右指针所指向的对象的引用计数+1）
4. 析构函数中引用计数减1；
5. 在赋值运算符和析构函数中，如果减1后为0，则调用`delete`释放对象。

#### 7.左值和右值

- 左值：指表达式结束后依然存在的**持久对象**，**可以取地址**，具名变量或对象 。
- 右值：表达式结束后就不再存在的**临时对象**，**不可以取地址**，没有名字。
- 引用是C++语法做的优化，**引用的本质还是靠指针来实现的**。**引用相当于变量的别名**。引用可以改变指针的指向，还可以改变指针所指向的值。
  - 左值引用：type &引用名 = 左值表达式；
  - 右值引用：type &&引用名 = 右值表达式；

 在C++11中，标准库在中提供了一个有用的函数std::move，std::move并不能移动任何东西，它唯一的功能是**将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义**。从实现上讲，std::move基本等同于一个类型转换：`static_cast<T&&>(lvalue);`

### std::move的优点

- std::move语句可以将左值变为右值而**避免拷贝构造**。
- std::move是**将对象的状态或者所有权从一个对象转移到另一个对象**，只是转移，**没有内存的搬迁或者内存拷贝。**

支持移动语义，用以避免非必要拷贝和临时对象。

##### 左值和右值的区别

1. 左值可以寻址，而右值不可以。
2. 左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。

```C++
int i=42;//i是左值， 42是右值
int && a = 1; //实质上就是将不具名(匿名)变量1取了个别名a
//左值引用只能绑定左值
int &r=i;   //正确，r引用i，i是一个左值，r是一个左值引用
int &r2=i*42;  //错误，i*42是一个右值
//右值引用只能绑定右值
int &&r2=i*42; //正确，将r2绑定到乘法结果上
int &&rr=i   //错误，不能将一个右值引用绑定到一个左值上
//常量左值引用却是个奇葩，它可以算是一个“万能”的引用类型，缺点是，只能读不能改。
const int &r3=i*42;  //正确，我们可以将一个const的引用绑定到一个右值上
A getTemp()
{
    return A();
}
A && a = getTemp();   //getTemp()的返回值是右值（临时变量）
const A & a = getTemp();   //不会报错 而 A& a 会报错
```

- getTemp()返回的右值本来在表达式语句结束后，其生命也就该终结了（因为是临时变量），**而通过右值引用，该右值又重获新生，其生命期将与右值引用类型变量a的生命期一样，只要a还活着，该右值临时变量将会一直存活下去**。实际上就是给那个临时变量取了个名字。

![img](https://camo.githubusercontent.com/edf861e75e4cbc4067cacdfe145d38c9fa696ae0949c8f971252a59461fec180/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f343432373236332d383161343766646339623864396539382e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f3236342f666f726d61742f77656270)

（**偷了临时变量的值，让临时变量的指针指向nullptr，否则会被析构掉，偷也白偷**）



所谓转发，就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的。



##### emplace_back减少内存拷贝和移动

我们之前使用vector一般都喜欢用push_back()，由上文可知容易发生无谓的拷贝，解决办法是为自己的类增加移动拷贝和赋值函数，但其实还有更简单的办法！就是使用emplace_back()替换push_back()

emplace_back()可以直接通过构造函数的参数构造对象，但前提是要有对应的构造函数。

对于map和set，可以使用emplace()。基本上emplace_back()对应push_bakc(), emplce()对应insert()。



#### 8.位操作

- **交换符号将正数变成负数，负数变成正数**

```c++
int reversal(int a) {
  return ~a + 1;
}
```

整数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数

- **取绝对值**

- ```c++
  int abs(int a) {
    int i = a >> 31;
    return i == 0 ? a : (~a + 1);
  }
  ```

- ### 位操作进行高低位交换

```c++
unsigned short a = 34520;
a = (a >> 8) | (a << 8);
```

- 削最后一位的1

- ```text
  x & (x - 1) 用于消去x最后一位的1
  x = 1100
  x - 1 = 1011
  x & (x - 1) = 1000
  ```



#### 9.**面向对象的三个特性**

面向对象的三个基本特征是：**封装、继承、多态**。

- 封装可以隐藏实现细节，使得代码模块化；
- 继承可以扩展已存在的代码模块（类）；它们的目的都是为了代码重用。
- 多态是实现的目的是为了接口重用

##### 五大原则 SOLID

| 简写 | 全拼                                | 中文翻译     |
| ---- | ----------------------------------- | ------------ |
| SRP  | The Single Responsibility Principle | 单一责任原则 |
| OCP  | The Open Closed Principle           | 开放封闭原则 |
| LSP  | The Liskov Substitution Principle   | 里氏替换原则 |
| ISP  | The Interface Segregation Principle | 接口分离原则 |
| DIP  | The Dependency Inversion Principle  | 依赖倒置原则 |

###### 1.  单一责任原则

> 修改一个类的原因应该只有一个。

换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。

如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。

###### 2. 开放封闭原则

> 类应该对扩展开放，对修改关闭。

扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。

符合开闭原则最典型的设计模式是**装饰者模式**，它可以动态地将责任附加到对象上，而不用去修改类的代码。

###### 3. 里氏替换原则

> 子类对象必须能够替换掉所有父类对象。

继承是一种 IS-A 关系，**子类需要能够当成父类来使用**，并且需要比父类更特殊。

如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。

###### 4. 接口分离原则

> 不应该强迫客户依赖于它们不用的方法。

**因此使用多个专门的接口比使用单一的总接口要好。**

###### 5. 依赖倒置原则

> **高层模块不应该依赖于低层模块，二者都应该依赖于抽象；**
> **抽象不应该依赖于细节，细节应该依赖于抽象。**

高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。

依赖于抽象意味着：

- 任何变量都不应该持有一个指向具体类的指针或者引用；
- 任何类都不应该从具体类派生；
- 任何方法都不应该覆写它的任何基类中的已经实现的方法。



#### 10.C++ 11

auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导

nullptr关键字：nullptr是一种特殊类型的字面值，**它可以被转换成任意其它的指针类型**；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。

智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。

**初始化列表：使用初始化列表来对类进行初始化**

**右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率**

lambda函数

> [capture]：该列表出现在lambda函数的开始位置，编译器根据[]来判断接下来的代码是否为lambda函数，捕捉列表可以捕捉上下文中的变量供lambda函数使用
>
> lambda的优点是：**可以编写内嵌的匿名函数，而不必编写独立函数或函数对象，使得代码更加的容易理解和精简。**
>
> Lambda的类型被定义为“闭包”的类，其通常用于STL库中，在某些场景下可用于简化仿函数的使用，同时Lambda作为局部函数，也会提高复杂代码的开发加速，轻松在函数内重用代码，无须费心设计接口。
>
> **Lambda表达式与普通函数最大的区别就是其可以通过捕获列表访问一些上下文中的数据**（其可见范围内的外部变量）。捕获列表描述了上下文中那些数据可以被lambda使用，以及使用的方式传值还是引用
>
> a [var]:表示值传递方式捕获变量var b [=]:表示值传递方式捕获所有父作用域中的变量(包括this) c [&var]:表示引用传递变量var d [&]:表示引用传递捕获所有父作用域中的变量(this) e [this]：表示值传递方式捕获当前的this指针
>
> 隐式捕获有两种方式，分别是[=]和[&]。[=]表示以值捕获的方式捕获外部变量，[&]表示以引用捕获的方式捕获外部变量。



#### 11.new与malloc的区别，delete和free的区别？

free和malloc匹配：释放malloc出来动态内存;

delete和new匹配：释放new出来的动态内存空间。

1.new和delete是关键字，需要编译器的支持；malloc和free是库函数，需要包含库头文件。

2.malloc/free是c/c++标准库的函数，**new/delete除了分配空间还会调用构造函数和析构函数进行初始化和清理（清理成员）**。

3.**malloc/free需要手动计算类型大小且返回值是void*(需要强转)，new/delete可以自己计算类型大小，返回对应的指针。**

4.对于自定义类型new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。（对malloc和free进行了封装）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

5.**在类和对象的时候会有很大区别。在使用malloc和free来处理动态内存的时候，仅仅是释放了这个对象所占的内存，而不会调用这个对象的析构函数；使用new和delete就可以既释放对象的内存的同时，调用这个对象的析构函数。**

**如果问到malloc，还有可能问你memcpy等realloc函数能不能在C++中使用，绝对不能，因为这些函数进行的都是内存值拷贝（也就是对象的浅拷贝），会发生浅拷贝这个严重的问题！**



#### 12.C++ 中的四种强制类型转换

隐式类型转换是安全的，显式类型转换是有风险的，C语言之所以增加强制类型转换的语法，就是为了强调风险，让程序员意识到自己在做什么。但比较粗。为了使潜在风险更加细化，使问题追溯更加方便，使书写格式更加规范，C++ 对类型转换进行了分类，并新增了四个关键字来予以支持，它们分别是：

![image-20210828114959383](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210828114959383.png)

http://c.biancheng.net/cpp/biancheng/view/3297.html

##### static_cast

> 用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转换，如果向下转换能成功但是不安全，结果未知；

- static_cast **只能用于良性转换，这样的转换风险较低，**一般不会发生什么意外
- static_cast 不能用于无关类型之间的转换，因为这些转换都是有风险的，

> - 两个具体类型指针之间的转换，例如`int *`转`double *`、`Student *`转`int *`等。不同类型的数据存储格式不一样，长度也不一样，用 A 类型的指针指向 B 类型的数据后，会按照 A 类型的方式来处理数据：如果是读取操作，可能会得到一堆没有意义的值；如果是写入操作，可能会使 B 类型的数据遭到破坏，当再次以 B 类型的方式读取数据时会得到一堆没有意义的值。
> - int 和指针之间的转换。将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件。

- static_cast 也不能用来去掉表达式的 const 修饰和 volatile 修饰。换句话说，不能将 const/volatile 类型转换为非 const/volatile 类型。

**static_cast 是“静态转换”的意思，也就是在编译期间转换，转换失败的话会抛出一个编译错误。**

##### const_cast 关键字

> 用于将const变量转为非const这个转换类型操纵传递对象的const属性，或者是设置或者是移除

const_cast 比较好理解，它用来去掉表达式的 const 修饰或 volatile 修饰。换句话说，const_cast 就是用来将 const/volatile 类型转换为非 const/volatile 类型。

- 这是因为 C++ 对常量的处理更像是编译时期的`#define`，是一个值替换的过程，代码中所有使用 n 的地方在编译期间就被替换成了 100。

使用 const_cast 进行强制类型转换可以突破 C/C++ 的常数限制，修改常数的值，因此有一定的危险性；但是程序员如果这样做的话，基本上会意识到这个问题，因此也还有一定的安全性。

##### reinterpret_cast关键字

> 就像传统的类型转换一样对待所有指针的类型转换。几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；



**reinterpret 是“重新解释”的意思，顾名思义，reinterpret_cast 这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。**

reinterpret_cast 可以认为是 static_cast 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换（有些编译器只允许 int 转指针，不允许反过来）。

可以想象，用一个 float 指针来操作一个 char 数组是一件多么荒诞和危险的事情，这样的转换方式不到万不得已的时候不要使用。将`A*`转换为`int*`，使用指针直接访问 private 成员刺穿了一个类的封装性，更好的办法是让类提供 get/set 函数，间接地访问成员变量。

##### dynamic_cast 关键字

> **用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。**只用于对象的指针和引用。向下转化时，会进行检查，检查转换是否会返回一个被请求的有效的完整对象。检测在运行时进行。如果是非法的，对于指针返回NULL，对于引用抛*bad_cast*异常。

dynamic_cast 用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功。

dynamic_cast 与 static_cast 是相对的，dynamic_cast 是“动态转换”的意思，static_cast 是“静态转换”的意思。dynamic_cast 会在程序运行期间借助 RTTI 进行类型转换，这就要求基类必须包含虚函数；static_cast 在编译期间完成类型转换，能够更加及时地发现错误。

dynamic_cast <newType> (expression)

**newType 和 expression 必须同时是指针类型或者引用类型。换句话说，dynamic_cast 只能转换指针类型和引用类型，其它类型（int、double、数组、类、结构体等）都不行。**

**对于指针，如果转换失败将返回 NULL；对于引用，如果转换失败将抛出`std::bad_cast`异常**

> 总起来说，dynamic_cast 会在程序运行过程中遍历继承链，如果途中遇到了要转换的目标类型，那么就能够转换成功，如果直到继承链的顶点（最顶层的基类）还没有遇到要转换的目标类型，那么就转换失败。对于同一个指针（例如 pa），它指向的对象不同，会导致遍历继承链的起点不一样，途中能够匹配到的类型也不一样，所以相同的类型转换产生了不同的结果。
>
> 从表面上看起来 dynamic_cast 确实能够向下转型，本例也很好地证明了这一点：B 和 C 都是 A 的派生类，我们成功地将 pa 从 A 类型指针转换成了 B 和 C 类型指针。**但是从本质上讲，dynamic_cast 还是只允许向上转型，因为它只会向上遍历继承链。**造成这种假象的根本原因在于，**派生类对象可以用任何一个基类的指针指向它**，这样做始终是安全的。本例中的情况②，pa 指向的对象是 D 类型的，pa、pb、pc 都是 D 的基类的指针，所以它们都可以指向 D 类型的对象，**dynamic_cast 只是让不同的基类指针指向同一个派生类对象罢了**。
>
> 

##### 为什么不使用C的强制转换？

C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

转换的含义是通过改变一个变量的类型为别的类型从而改变该变量的表示方式。为了类型转换一个简单对象为另一个对象你会使用传统的类型转换操作符。比如，为了转换一个类型为doubole的浮点数的指针到整型：i = (int) d;或者：i = int (d);对于具有标准定义转换的简单类型而言工作的很好。



#### 13.Static 相关问题

### static关键字的作用

全局变量、静态局部变量、静态全局变量都在**静态存储区**分配空间，而局部变量在**栈分配空间**。

把局部变量改变为静态变量后是改变了他的存储方式，即改变了他的生存期。

把全局变量改变为静态变量后是改变了他的作用域，限制了他的使用范围。

因此static这个说明符在不同的地方起的作用是不同的。

##### 1.全局静态变量

在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.

未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

**全局静态变量和非静态全局变量的区别**：作用域

非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。

而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其他源文件中不能使用它。**由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。**

##### 2.局部静态变量

在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。

未经初始化的局部静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。**但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；**

**局部静态变量和非静态局部变量的区别**

局部静态变量会被放在程序的静态数据存储区里，这样可以在**下一次调用的时候还可以保持原来的赋值。**这一点是他与堆栈变量和堆变量的区别。局部变量在栈分配空间

##### 3.静态函数

**头文件中声明非static的全局函数，代表多个cpp可以用**

**cpp内声明static的全局函数，代表只是本cpp可以用**，不会引起其他cpp内的命名冲突

##### 4.类的静态成员

在类中，静态成员可以实现多个对象之间的**数据共享**，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用

##### 5.类的静态函数

**静态成员函数和静态数据成员一样，它们都属于类的静态成员，**它们都不是对象成员。因此，**对静态成员的引用不需要用对象名**。

**在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员**（这点非常重要）。**如果静态成员函数中要引用非静态成员时，可通过对象来引用**。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);

##### 6.**类的静态函数和类的普通成员函数的区别**

普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this->fn()。

但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。如果静态成员函数中要引用非静态成员时，可通过对象来引用。

##### 7.静态变量什么时候初始化

静态变量存储在虚拟地址空间的数据段和bss段，

C语言中其在代码执行之前初始化，属于编译期初始化。

而C++中由于引入对象，对象生成必须调用构造函数，**因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造**

**static作用：“改变生命周期” 或者 “改变作用域”**

程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆）中。



#### 14.class 和 struct的区别

在c中struct是一个数据类型，所以只能有数据，不能有操作也就是函数。因为面向过程的编程认为，数据和数据操作是分开的。

然而当struct进入面向对象的c++时，其特性也有了新发展，**其struct可以包含成员函数**，因为在c++中认为数据和数据对象是一个整体，不应该分开，这就是struct在c和c++两个时代的差别。还可以实现继承，多态。

对于C++而言

##### **1.默认的继承访问权。class默认的是private,strcut默认的是public。**

同时，struct可以继承class，同样class也可以继承struct，那么默认的继承访问权限是看子类到底是用的struct还是class。

##### **2.默认访问权限：struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。**

##### **3.“class”这个关键字还用于定义模板参数，就像“typename”。但关键字“struct”不用于定义模板参数**

从上面的区别，我们可以看出，struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。

##### **4.class和struct在使用大括号{ }上的区别**

- 关于使用大括号初始化

 1.）class和struct如果定义了构造函数的话，都不能用大括号进行初始化 　　2.）如果没有定义构造函数，struct可以用大括号初始化。 　　3.）如果没有定义构造函数，且所有成员变量全是public的话，class可以用大括号初始化。

**两者最大的区别就在于思想上，c语言编程单位是函数，语句是程序的基本单元。而C++语言的编程单位是类。从c到c++的设计由过程设计为中心向以数据组织为中心转移。**



##### 使用初始化列表的原因

初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。

主要是**性能问题**，对于内置类型，如int, float等，使用初始化类表和在构造函数体内初始化差别不是很大，**但是对于类类型来说，最好使用初始化列表**，为什么呢？因为使用初始化列表少了**一次调用默认构造函数的过程**，这对于数据密集型的类来说，是非常高效的。



#### 15.vector 和List的区别

##### Vector

连续存储的容器，动态数组，在堆上分配空间

底层实现：数组

**适用场景：经常随机访问，且不经常对非尾节点进行插入删除。**

vectro扩容：

> vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后（插入指定位置），然后调整迭代器。
>
> 如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。

##### List

SGI STL 的 list 是一个双向链表，同时还是一个环状的双向链表；对于任何位置的元素插入或元素移除，list 永远是常数时间。

动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。

底层：双向链表

性能：

访问：随机访问性能很差，只能快速访问头尾节点。

插入：很快，一般是常数开销

删除：很快，一般是常数开销

适用场景：经常插入删除大量数据



##### Vector和List区别：

1）vector底层实现是数组；list是双向链表。

2）vector支持随机访问，list不支持。

3）vector是顺序内存，list不是。

4）vector在中间节点进行插入删除会导致内存拷贝，list不会。

5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。

6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。

### Vector和List应用

vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。

list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。

##### deque

- deque 是一种双向开口的连续线性空间。可以在头尾两端分别做元素的插入和删除操作。
- **deque 和 vector 的差异：第一，deque 允许于常数时间内对起头端进行元素的插入或移除操作；第二，deque 没有容量，它是动态地以分段连续空间组合而成。**
- **deque 由一段段的定量连续空间构成。一旦有必要在 deque 的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个 deque 的头端或尾端**
- 因为 deque 是一段段的定量连续空间构成。为了方便管理这些一段段连续空间，同时对用户来说，deque 整体是连续的，所以需要采用一小块连续空间 map 作为控制单元，其中 map 中的每个节点 node 都是指针，指向 deque 的一段段连续空间 buffer 缓冲区
- （一个小块连续空间 map 包含节点数，最少 8 个，最多是所需节点数加上 2。）
- ![img](https://raw.githubusercontent.com/steveLauwh/SGI-STL/master/The%20Annotated%20STL%20Sources%20V3.3/Other/deque%20DS.PNG)

deque是介于两者之间，它兼顾了数组和链表的优点，它是分块的链表和多个数组的联合。所有它有比list好的查询性能，有比vector好的插入删除性能。如果你需要随机存取又关心两端数据的插入和删除，那么deque是最佳之选。

array也位于名称空间std中,与数组一样,array对象的长度也是固定的,也使用栈(静态内存分配),而不是自由存储区,因此其效率与数组相同,但更方便,更安全.



#### 16.函数指针vs指针函数

### 函数指针

##### 定义

函数指针是指向函数的指针变量。int (*fp)();

```C++
一、
char * fun(char * p)  {…}    // 函数fun
char * (*pf)(char * p);       // 函数指针pf
pf = fun;            // 函数指针pf指向函数fun
pf(p);            // 通过函数指针pf调用函数fun
二、
int add(int, int);
int sub(int, int);
//int (*fp)(int, int)
int calc(int (*fp)(int, int), int, int);// 函数指针pf
calc(add, 3, 5);//这里相当于 pf = add
```

### 指针函数

##### 定义

使用指针变量作为函数的返回值  char *getWord(char);



#### 17.函数调用

##### 怎么进行函数调用

**每一个函数调用都会分配函数栈**，在栈内进行函数执行过程。

调用前，**先把返回地址压栈**，然后把当前函数的**esp指针压栈**。

##### 参数压栈顺序

从右到左

##### 如何处理返回值

**生成一个临时变量，把它的引用作为函数参数传入函数内。**

常规程序中，函数返回的指针通常应该是：

(1)指向静态（static）变量； (2)指向专门申请分配的（如用malloc）空间； (3)指向常量区（如指向字符串"hello"）； (4)指向全局变量； (5)指向程序代码区（如指向函数的指针）。



#### 18.值传递、指针传递和引用传递

总结一下值传递、指针传递和引用传递不同的地方，

首先它们都是可以把值传递给函数的只不过是传递的方式不同，有一点是可以很明显的，指针传递和引用传递都会改变b的值，值传递不会，这就是值传递和另外两个的区别，而指针传递和引用传递的不同的地方则是指针传递的是b的地址，而引用传递则等于给b起了一个别名，然后通过别名来操作b的值，和它所在的内存地址。



#### 19.隐式转换

首先，对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换，其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。

为什么c++需要隐式类型转换？

1. c++多态的特性，就是通过父类的对象实现对子类的封装，**以父类的类型返回子类对象**。
2. **c++中使用父类的地方一定可以使用子类代替，这也得益于隐式类型转换。**
3. **c++是一种强类型的语言，有着非常严格的类型检查，采用隐式类型转换会使程序员更方便快捷一**点。
4. 但是在享受方便的时候，风险也紧跟其后

##### explicit关键词的用法

在强转中，对于单参数的构造函数，支持隐式类型的转换，所以当我们不需要隐式类型的转换的时候，我们就可以**加上explicit关键字来防止，在构造函数的时候发生隐式类型的转换。** 单参数的类构造函数的隐式类型转换。

##### 函数重载

C++中，如果同时定义了多个函数名称相同，但函数签名(参数，返回值)不同的函数，则此行为称为函数重载。调用重载函数时，编译器将根据调用的参数数量与类型确定被调用的是哪一个函数，此过程称为重载确定。在重载确定过程中，如果编译器发现不止一个函数都是当前调用的最佳版本，则将引发二义性编译时错误。

##### 重载（编译时多态）和覆盖（运行时多态）

方法的覆盖是子类和父类之间的关系，是垂直关系；

方法的重载是同一个类中方法之间的关系，是水平关系。

重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中 覆盖：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写/覆盖



#### 20.虚函数    https://blog.csdn.net/haoel/article/details/1948051

C++中的虚函数的作用主要是实现了多态的机制。**关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。**

**这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。**

什么是多态性：不同对象收到相同的消息，产生不同的动作。“一个接口，多种方法”，即用同样的接口访问功能不同的函数。

##### 虚函数

当一个类中包含被virtual 关键字修饰的成员函数时，该成员函数就成为了一个虚函数。

**虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的**。简称为V-Table。在这个表中，**主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其真实反应实际的函数**。这样，在有虚函数的类的实例中这个**表被分配在了这个实例的内存中**，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

C++的编译器应该是**保证虚函数表的指针存在于对象实例中最前面的位置**（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。

**在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。**

##### 虚函数表

虚函数表： **同属一个类的不同的实例化对象其实是共用一张虚函数表的**，在对象中含有一个虚函数指针 ***_vptr**, 该指针指向该类的虚函数表**，虚函数表保存的是类中虚函数的地址（一个类可能有多个虚函数）**。

> C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 **这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数**。

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable1.jpg)

>  注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。

###### 1. 一般继承（无虚函数覆盖）没有覆盖父类的虚函数是毫无意义的

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_Drawing3.jpg)

请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：对于实例：Derive d; 的虚函数表如下：

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable2.JPG)

*我们可以看到下面几点：*

1）虚函数按照其声明顺序放于表中。

2）父类的虚函数在子类的虚函数前面。

###### 2.一般继承（有虚函数覆盖）

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_Drawing4.jpg)

f() 覆盖（也就是运行时的多态）

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable3.JPG)

*我们从表中可以看到下面几点，*

**1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。**

2）没有被覆盖的函数依旧。

> 当一个子类继承了一个含有虚函数的基类，并重写了该基类中的一个虚函数，我们就说这两个类构成多态。子类继承基类的同时，基类的虚函数表也被子类继承，**不同的是被子类重写的虚函数将会替代原来虚函数表中对应的基类的虚函数的地址。**从而基类与子类调用同名的虚函数时，所调用的就不是同一个函数，从而体现了多态和虚函数表的作用。

###### 多重继承，无虚函数覆盖

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_Drawing1.jpg)

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable4.JPG)

*我们可以看到：*

1） 每个父类都有自己的虚表。

2） **子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）**

 这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。



###### 多重继承，有虚函数覆盖

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_Drawing2.jpg)

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable5.jpg)

我们可以看见，三个父类虚函数表中的*f()*的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。

> 虚函数表存在一些安全性，比如强制用基类的指针访问派生类自己定义的虚函数，或者访问一些non-public的虚函数

##### 为什么父类的析构函数必须是虚函数？

将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，**防止内存泄漏。**

##### 为什么C++默认的析构函数不是虚函数

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，**占用额外的内存**。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是**只有当需要当作父类时，设置为虚函数。**

##### 虚函数在内存哪里?

如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。

如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。

如果类中成员是virtual属性，会隐藏父类对应的属性。

#### 21.构造函数的初始化列表

![image-20210830004349257](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210830004349257.png)

#### 22.为什么sizeof 一个空类，结果为1     sizeof相关

##### 为什么C++中的大小会是1？

空类同样可以被实例化

C++标准中规定，**任何不同的对象不能拥有相同的内存地址。** 如果空类大小为0，当我们声明一个这个类的对象数组，那么数组中的每个对象都拥有了相同的地址，这显然是违背标准的

类对象的计算

- 空类大小为1字节
- 一个类中，虚函数本身、成员函数和静态成员数据不占用类对象存储空间
- 包含了虚函数的类，只有一个虚指针vptr的大小
- 普通继承，派生类继承了基类的函数和成员，要按照字节对齐来计算大小       // 8byte
- 虚函数继承，都是继承的基类的vptr
- 虚继承，继承基类的vptr

静态数据成员被编译器放在程序的一个global data members中，它是类的一个数据成员，但不影响类的大小。不管这个类产生了多少个实例，还是派生了多少新的类，**静态数据成员只有一个实例**。**静态数据成员，一旦被声明，就已经存在。** 

1.普通单继承,继承就是基类+派生类自身的大小(注意字节对齐)

- **注意：类的数据成员按其声明顺序加入内存，无访问权限无关，只看声明顺序。**

2.虚单继承，派生类继承基类vptr









#### 23.RTTI

*RTTI*是”Runtime Type Information”的缩写,意思是**运行时类型信息**,它提供了**运行时确定对象类型的方法**。

运行时类型检查，在C++层面主要体现在**dynamic_cast**和**typeid**, VS中虚函数表的-1位置存放了指向type_info的指针。

**对于存在虚函数的类型**，typeid和dynamic_cast都会去查询type_info

**它使程序能够获取由基指针或引用所指向的对象的实际派生类型，即允许“用指向基类的指针或引用来操作对象”的程序能够获取到“这些指针或引用所指对象”的实际派生类型**。

###### typeid

如果typeid的操作数不是类类型或者是没有虚函数的类，则typeid指出该操作数的静态类型。如果操作数是定义了至少一个虚函数的类类型，则在运行时计算类型。

`A  *p = new B(); `    ``        `typeid(p).name()`;         //如果classB中的print函数为virtual函数，那么就会输出P 的类型为class B*

###### dynamic_cast

强制类型转换的一种

允许运行时刻进行类型转换，从而使程序能够在一个类层次结构中安全地转化类型，与之相对应的还有一个非安全的转换操作符static_cast。

向下转化时，会进行检查，检查转换是否会返回一个被请求的有效的完整对象。检测在运行时进行。如果是非法的，对于指针返回NULL，对于引用抛*bad_cast*异常。

当类中存在虚函数时，编译器就会在类的成员变量中添加一个指向虚函数表的vptr指针，每一个class所关联的type_info object也经由virtual table被指出来，通常这个type_info object放在表格的第一个slot。当我们进行dynamic_cast时，编译器会帮我们进行语法检查。如果指针的静态类型和目标类型相同，那么就什么事情都不做；否则，首先对指针进行调整，使得它指向vftable，并将其和调整之后的指针、调整的偏移量、静态类型以及目标类型传递给内部函数。其中最后一个参数指明转换的是指针还是引用。**两者唯一的区别是，如果转换失败，前者返回NULL，后者抛出bad_cast异常**。

#### 24 宏和函数有什么区别

1. 宏做的是简单的字符串替换(注意是字符串的替换,不是其他类型参数的替换),而函数的参数的传递,参数是有数据类型的,可以是各种各样的类型.
2. 宏的参数替换是不经计算而直接处理的,而函数调用是将实参的值传递给形参,既然说是值,自然是计算得来的.
3. 宏在编译之前进行,即先用宏体替换宏名,然后再编译的,而函数显然是编译之后,在执行时,才调用的.因此,宏占用的是编译的时间,而函数占用的是执行时的时间.
4. 宏的参数是不占内存空间的,因为只是做字符串的替换,而函数调用时的参数传递则是具体变量之间的信息传递,形参作为函数的局部变量,显然是占用内存的.
5.  函数的调用是需要付出一定的时空开销的,因为系统在调用函数时,要保留现场,然后转入被调用函数去执行,调用完,再返回主调函数,此时再恢复现场,这些操作,显然在宏中是没有的.

###### assert

- 断言是宏，而非函数。作用是如果它的条件返回错误，则终止程序执行。可以通过定义NDEBUG来关闭assert，需要在include之前。

- void assert(int expression); **断言主要用于检查逻辑上不可能的情况**。

例如，**它们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。**

**与正常的错误处理不同，断言通常在运行时被禁用**



#### 25 const 的作用

##### const作用

1. 定义常量

   const int a = 100;//常量表达式

   const double b = 2.0;//常量

   只有变量是枚举类型或者整数，并且以常量表达式初始化才是常量表达式。

2. 检查类型

   \#define宏定义没有类型，const常量有类型，编译器可以进行安全检查

3. 防止修改

   限制函数参数不能修改

4. 可以节省空间

   从汇编角度来看，const常量只是给出地址，而不是像#define一样给出立即数，因此在运行时只有一份拷贝

##### 指针和常量

> const char *a;// 常量指针，指向常量的指针
> char *const a;// 指针常量，指针本身是常量
> const char * const a;// 指针本身是常量，并且指向常量

如果*const*位于`*`的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；

如果const位于`*`的右侧，*const*就是修饰指针本身，即指针本身是常量。

**对于指向常量的指针，**

1. 不能通过指针来修改对象的值。
2. **也不能使用void`*`指针保存const对象的地址，必须使用const void`*`类型的指针保存const对象的地址。**
3. 允许把非const对象的地址赋值给const对象的指针，如果要修改指针所指向的对象值，必须通过其他方式修改，不能直接通过当前指针直接修改。

> 将非const对象的地址赋给const对象的指针:
>
> 1. `constint*ptr;`
> 2. `int val =3;`
> 3. `ptr =&val;//ok`
>
> 虽然常量指针指向非const对象，但是仍然不能通过指针修改非const对象的值。
>
> 我们不能通过ptr指针来修改val的值，即使它指向的是非const对象!
>
> 我们不能使用指向const对象的指针修改基础对象，然而如果该指针指向了非const对象，可用其他方式修改其所指的对象。可以修改const指针所指向的值的，但是不能通过const对象指针来进行而已！如下修改：
>
> **（可以再定义一个非const指针修改val的值）**
>
> 1. `int*ptr1 =&val;`
> 2. `*ptr1=4;`
> 3. `cout<<*ptr<<endl`

**对于指针常量**

> const指针必须进行初始化，且const指针的值不能修改。
>
> 当把一个const常量的地址赋值给ptr时候，由于ptr指向的是一个变量，而不是const常量，所以会报错

**也就是说指向常量的指针可以指向常量也可以指向变量，但指向非常量的指针只能指向非常量。**

##### 函数中使用const

1. const修饰函数返回值

2. const修饰函数参数

   1. void fun(int *const var)// 指针本身不可变，无意义
   2. void fun(const char *dst)//参数指针所指内容为常量不可变
   3. void fun(const A &a)//提高效率，同时防止修改

3. const修饰成员函数

   1. **任何不会修改数据成员的成员函数都应该声明为const类型**

   2. **只有常成员函数才有资格操作常量或常对象**

   3. **类中的const成员变量必须通过初始化列表进行初始化**

      还可以通过与static结合在类外定义，或者在定义处初始化

   4. **const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.**



小结：对于**非内部数据类型**的输入参数，**应该将“值传递”的方式改为“const 引用传递”**，目的是提高效率。例如将void func(A a) 改为void func(const A &a)。

> 对于非内部数据类型的参数而言，象void func(A a) 这样声明的函数注定效率比较低。因为函数体内将产生A 类型
>
> 的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。
>
> 为了提高效率，可以将函数声明改为void func(A &a)，因为**“引用传递”仅借用一下参数的别名而已，不需要产生临**
>
> **时对象。**但是函数void func(A &a) 存在一个缺点：**“引用传递”有可能改变参数a，这是我们不期望的。**解决这个问题很容易，加const修饰即可，因此函数最终成为
>
> void func(const A &a)。

**对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。**否则既达不到提高效率的目的，又降低了函数的可理解性。例如void func(int x) 不应该改为void func(const int &x)。

我们除了上述的初始化const常量用初始化列表方式外，也可以通过下面方法：

static const int const_num ;  然后在类外  const int Apple::const_num  = 1； 结合来进行初始化。

**static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化**。

![image-20210907162718187](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210907162718187.png)



#### 26 decltype用法总结

- 推导出表达式类型，只查询，不计算

- ### 与using/typedef合用，用于定义类型 （using 可以用于模板别名，typedef 不可用于模板别名。）

> ```C++
> using size_t = decltype(sizeof(0));//sizeof(a)的返回值为size_t类型
> using ptrdiff_t = decltype((int*)0 - (int*)0);
> using nullptr_t = decltype(nullptr);
> vector<int >vec;
> typedef decltype(vec.begin()) vectype;
> ```

- 重用匿名函数

> ```C++
> struct 
> {
>     int d ;
>     doubel b;
> }anon_s;
> // 这个结构体是匿名的，只有一个anon_s对象
> 
> // 借助decltype，我们可以重新使用这个匿名的结构体
> decltype(anon_s) as ;//定义了一个上面匿名的结构体
> ```

- ### 泛型编程中结合auto，用于追踪函数的返回值类型

> ```C
> // 后置返回类型
> template <typename T>
> auto multiply(T x, T y)->decltype(x*y)
> {
>     return x*y;
> }
> ```

#### 27 . C++的直接初始化与复制初始化

- C++中的**直接初始化**指的是直接调用类的构造函数进行初始化，例如

> string a; //调用默认构造函数
>
> string a("hello");  //调用参数为const char *类型的构造函数
>
> string b(a);   //调用拷贝构造函数

**复制初始化**指的是用“=”号来初始化对象，例如

> string a = "hello";
>
> string b = a;

根据C++的标准，**直接初始化就是直接调用类的构造函数来初始化对象，**例如在string a(“hello”)中，string类的string(const char *)构造函数会被调用，a被直接初始化。

**复制初始化应该是先调用对应的构造函数创建一个临时对象，再调用拷贝构造函数将临时对象拷贝给要创建的对象。**例如在string a=”hello”中，string类的string(const char *)构造函数会被首先调用，创建一个临时对象，然后拷贝构造函数将这个临时对象复制到a。

**但为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化了。**

不过存在两个特例

1. **当拷贝构造函数为private时。**

> 虽然编译器会跳过创建临时对象这一步，但是这个类必须要能够正确的调用指定的构造函数和拷贝构造函数才能编译通过。优化是编译器采取的措施，但是程序必须使得不优化时代码也符合语法。

2. **当拷贝构造函数为explicit，或者指定的构造函数为explicit时。**

   > C++中如果一个构造函数为explicit，那么只能显式调用这个构造函数，把这个构造函数用作“隐式类型转换”是不可以的。这时候复制初始化就会报错，只能显示调用。

#### 28. 友元

友元提供了一种 普通函数或者类成员函数 访问另一个类中的私有或保护成员 的机制。

1. 友元函数：普通函数对一个访问某个类中的私有或保护成员。
2. 友元类：类A中的成员函数访问类B中的私有或保护成员

优点：提高了程序的运行效率。

缺点：破坏了类的封装性和数据的透明性。

总结： - 能访问私有成员 - 破坏封装性 - 友元关系不可传递 - 友元关系的单向性 - 友元声明的形式及数量不受限制



在类声明的任何区域中声明，而定义则在类的外部。

**友元函数只是一个普通函数，并不是该类的类成员函数，它可以在任何地方调用，友元函数中通过对象名来访问该类的私有或保护成员。**

友元类的声明在该类的声明中，而实现在该类外。

**类B是类A的友元，那么类B可以直接访问A的私有成员。**



#### 29 .类内定义与内联函数的关系  inline

类内定义的成员函数，编译器会将其优先编译为内联函数，但是对于复杂的成员函数无法编译成内联函数的，就编译成普通的函数。

类中定义了的函数是隐式内联函数。

声明要想成为内联函数，必须在定义处加inline关键字。

inline要起作用,inline要与函数定义放在一起,inline是一种“用于实现的关键字,而不是用于声明的关键字

##### 优缺点

优点

1. 内联函数同宏函数一样将在被调用处进行代码展开，**省去了参数压栈、栈帧开辟与回收，结果返回**等，从而提高程序运行速度。
2. 内联函数相比宏函数来说，在代码展开时，**会做安全检查或自动类型转换**（同普通函数），而宏定义则不会。
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
4. 内联函数在运行时可调试，而宏定义不可以。

缺点

1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

#### 29 指针相关

##### 指针操作

```C++
int main(void)
{
	char *c[] = {"ENTER","NEW","POINT","FIRST"};     //字符指针
	char** cp[] = {c+3,c+2,c+1,c};                   //指针的指针
	char***cpp = cp;
	printf("%s\n", **++cpp);// ++cpp 会改变 cpp 的值
	printf("%s\n", *--*++cpp + 3);   //cpp 现在指向c+2的地址，++解析一层，即指向c+1，--变成c  再+3 就向后移动3个字符
	printf("%s\n", *cpp[-2]+3);//-2 并没有改变 cpp
	printf("%s\n", cpp[-1][-1]+1);
    
    // cout << "c:" << **++cpp << endl;    //cpp 地址指向c+2
    // cout << "c:" << cpp[-1][-1] << endl;           //第一个把cpp地址指向了c+2的前一个，也就是c+3 ，后一个对c+3减1  就是c+2

    return 0;
}
```

##### 野指针和悬挂指针的区别

- 悬挂指针：当指针所指向的对象被释放，但是该指针没有任何改变，以至于**其仍然指向已经被回收的内存地址**，这种情况下该指针被称为悬挂指针；

- 野指针：**未初始化的指针被称为野指针**。

##### this指针

###### this指针的用处

1. 一个对象的this指针并不是对象本身的部分，不影响sizeof结果
2. this指针作为非静态成员函数的隐含形参，对各成员的访问均通过this指针进行

###### this指针的使用

1. 返回类对象本身，return *this
2. 参数与成员变量同名时，this->n = n

this指针是A * const this。

如果是const函数，会变成const A *const this

this在成员函数在开始执行前构造，在成员的执行结束后清除。

###### delete this 合法吗？

合法，但：

1. 必须保证 this 对象是通过 `new`（不是 `new[]`、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的
2. 必须保证调用 `delete this` 的成员函数是最后一个调用 this 的成员函数
3. 必须保证成员函数的 `delete this `后面没有调用 this 了
4. 必须保证 `delete this` 后没有人使用了



#### 30.UML类图和时序图

https://www.cnblogs.com/wolf-sun/p/UML-Sequence-diagram.html

https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#generalization

- 继承结构表现为：实现和泛化

> 泛化关系表现为继承非抽象类,用一条带空心箭头的直接表示。
>
> 实现关系用一条带空心箭头的虚线表示；最终代码中，实现关系表现为继承抽象类；

- 聚合关系与组合关系

> 聚合关系用一条带空心菱形箭头的直线表示, **A聚合到B上，或者说B由A组成；**
>
> **与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在**；例如， 部门撤销了，人员不会消失，他们依然存在；
>
> 组合关系用一条带实心菱形箭头直线表示，**A组成B，或者B由A组成；**
>
> 但组合关系是一种强依赖的特殊聚合关系，**如果整体不存在了，则部分也不存在了**；例如， 公司不存在了，部门也将不存在了;

- 关联关系

> 关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；**在最终代码中，关联对象通常是以成员变量的形式实现的；**

- 依赖关系

> 依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；**他描述一个对象在运行期间会用到另一个对象的关系；**与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；
>
> 在最终代码中，**依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；**依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；

#### 31 . volatile关键字

1. **访问寄存器要比访问内存要块**，因此CPU会优先访问该数据在寄存器中的存储结果，但是**内存中的数据可能已经发生了改变**，**而寄存器中还保留着原来的结果**。**为了避免这种情况的发生将该变量声明为volatile，告诉CPU每次都从内存去读取数据。**
2. 一个参数可以即是const又是volatile的吗？可以，一个例子是只读状态寄存器，是volatile是因为它可能被意想不到的被改变，是const告诉程序不应该试图去修改他。

# 数据库

#### 1.索引

- 什么是覆盖索引https://juejin.cn/post/6844903967365791752
- 数据库中的各种连接 （多表查询）https://zhuanlan.zhihu.com/p/46037197

#### 2.语句相关

- and 权限比 or 高

##### 通配符 

怎样搜索产品名中包含文本anvil的所有产品？用简单的比较操作符肯定不行，必须使用通配符。利用通配符可创建比较特定数据的搜索模式。

1. %通配符，任何字符出现任何次数  （不匹配NULL）

![image-20210912213154550](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912213154550.png)

%abc%  可以包含开头和结尾字符

2. _ 下划线通配符，  只匹配单个字符

![image-20210912213525847](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912213525847.png)

#### 3. 计算字段

计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT语句内创建的。字段（field） 基本上与列（column）的意思相同，经常互换使用，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上。

##### 1. Concat()  拼接

![image-20210912220054164](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912220054164.png)

![image-20210912220221808](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912220221808.png)

- 此外还有LTrim() 和Trim()。	
- AS 关键字可以取别名
- ![image-20210912220451645](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912220451645.png)

#### 4. 文本处理函数

- ![image-20210912220810254](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912220810254.png)

![image-20210912220821078](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912220821078.png)



![image-20210912221250400](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912221250400.png)

![image-20210912221300572](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912221300572.png)





#### 5. 聚集函数

有时我们不需要实际检索出数据，而是只需要汇总数据，例如确定表中行数，获得表中行组的和或者是找处表列的最大值、最小值等。MYSQL提供5个聚集函数

![image-20210912221758084](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912221758084.png)	

![image-20210912221944742](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912221944742.png)

**可以加DISTINCT去除相同的值**

![image-20210912222103458](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912222103458.png)

**可以组合聚集函数**

![image-20210912223033977](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912223033977.png)



#### 6. 分组数据

分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算。

![image-20210912223809287](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912223809287.png)

- GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前

![image-20210912224209498](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912224209498.png)

- 目前为止所学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是WHERE过滤行，而HAVING过滤分组。

或者说where在分组前过滤，过滤的值不包含在分组中，having在分组后过滤，如下面的例子

![image-20210912224521493](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912224521493.png)

**小结**

![image-20210912224948007](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912224948007.png)
