面试被问到的问题

[toc]

## 9.4 号拼多多一面

- 自我介绍
- 相关课程询问
- 智能指针相关问题
- 一段代码编译的整个过程
- 一段程序是如何运行的（引导回答内存、虚拟内存等）

> 总结一下就是，虚拟内存是一个假象的内存空间，在程序运行过程中虚拟内存空间中需要被访问的部分会被映射到物理内存空间中。虚拟内存空间大只能表示程序运行过程中可访问的空间比较大，不代表物理内存空间占用也大。
>
> 驻留内存，顾名思义是指那些被映射到进程虚拟内存空间的物理内存。

![t1](http://www.bo56.com/wp-content/uploads/2013/08/t1.png)

- 了解lru吗
- 写lru算法题(leetcode 146)   实现哈希链表

> 我们可以总结出 cache 这个数据结构必要的条件：查找快，插入快，删除快，有顺序之分。
>
> 因为显然 cache 必须有顺序之分，以区分最近使用的和久未使用的数据；而且我们要在 cache 中查找键是否已存在；如果容量满了要删除最后一个数据；每次访问还要把数据插入到队头。
>
> 那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表。
>
> LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体
>
> ![HashLinkedList](https://pic.leetcode-cn.com/b84cf65debb43b28bd212787ca63d34c9962696ed427f638763be71a3cb8f89d.jpg)
>
> 为什么要是双向链表，单链表行不行？另外，既然哈希表中已经存了 key，为什么链表中还要存键值对呢，只存值不就行了？
>
> 1.双向链表
>
> 因为我们需要删除操作。删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱，保证操作的时间复杂度 `O(1)`。
>
> 2.为什么链表中还要存键值对
>
> 当缓存容量已满，我们不仅仅要删除最后一个 Node 节点，还要把 map 中映射到该节点的 key 同时删除，而这个 key 只能由 Node 得到。如果 Node 结构中只存储 val，那么我们就无法得知 key 是什么，就无法删除 map 中的键，造成错误。
>











