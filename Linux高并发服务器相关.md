# Linux高并发服务器相关

[toc]

#### 1.linux文件类型

Unix/Linux对数据文件(*.mp3、*.bmp)，程序文件(*.c、*.h、*.o)，设备文件（LCD、触摸屏、鼠标），网络文件( socket ) 等的管理都抽象为文件，使用统一的方式方法管理。 **Linux下一切皆文件。**

在Unix/Linux操作系统中也必须区分文件类型，通过文件类型可以判断文件属于可执行文件、文本文件还是数据文件。在Unix/Linux系统中文件可以没有扩展名。

![image-20210818170134805](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210818170134805.png)

> **1）普通文件**
>
> 普通文件是计算机操作系统用于存放数据、程序等信息的文件，一般都长期存放于外存储器（磁盘、磁带等）中。普通文件一般包括**文本文件、数据文件、可执行的二进制程序文件**等。
>
> 在Unix/Linux中可以通过file命令来查看文件的类型。如果file文件后面携带文件名，则查看指定文件的类型，如果携带通配符“*”，则可以查看当前目录下的所有文件的类型。
>
> **2）目录文件**
>
> Unix/Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。
>
> 目录文件只允许系统管理员对其进行修改，用户进程可以读取目录文件，但不能对它们进行修改。
>
> 每个目录文件至少包括两个条目，“..”表示上一级目录，“.”表示该目录本身。
>
> **3）设备文件**
>
> Unix/Linux系统把每个设备都映射成一个文件，这就是设备文件。它是用于向I/O设备提供连接的一种文件，分为字符设备和块设备文件。
>
> 字符设备的存取以一个字符为单位，块设备的存取以字符块为单位。每一种I/O设备对应一个设备文件，存放在/dev目录中，如行式打印机对应/dev/lp，第一个软盘驱动器对应/dev/fd0。
>
> > deng@itcast:~/share$ echo "hello world" > /dev/pts/22 hello world
>
> **4）管道文件**
>
> 管道文件也是Unix/Linux中较特殊的文件类型，这类文件多用于进程间的通信。
>
> 
>
> **5）链接文件**
>
> 似于 windows 下的快捷方式，链接又可以分为软链接（符号链接）和硬链接。

#### 2. ls -l 和 du的区别

ls 显示目录本身属性的大小，du显示目录内所有内容所占磁盘空间的大小

du == disk usage (磁盘使用量，占用的磁盘空间)

一个文件占用的磁盘空间和一个文件的大小是两码事情。占用空间取决于文件系统的块（block）的大小，linux一般默认是4k(4096) ,因此，一个大小为1个字节的文件，最小也要占用4k,如果你创建文件系统的时候制定块大小是16K，那么即便一个文件只有1个字节，占用空间也是16K。

**通常情况下，ls 显示的文件大小比du显示的磁盘占用空间小
原因：
比如文件系统的block是4K，一个13K的文件占用的空间是 13k/4k = 3.25 个block，一个block只能被一个文件占用，因此实际占用空间就是4个block，就是16K。**

#### 3 find grep

- find 查文件，grep 查文件里的内容（文本文件）



#### 4sh 和 bash

sh 遵循POSIX规范：“当某行代码出错时，不继续往下解释”。bash 就算出错，也会继续向下执行。

>POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ）。POSIX标准意在期望获得源代码级别的软件可移植性。换句话说，为一个POSIX兼容的操作系统编写的程序，应该可以在任何其它的POSIX操作系统上编译执行。

#### 5.文件时间

文件时间有以下三种：

- modification time (mtime)：文件的内容更新就会更新；
- status time (ctime)：文件的状态（权限、属性）更新就会更新；
- access time (atime)：读取文件时就会更新。

#### 6.硬链接和软连接

在linux系统中有种文件是链接文件，**可以为解决文件的共享使用。**链接的方式可以分为两种，一种是硬链接（Hard Link），另一种是软链接或者也称为符号链接（Symbolic Link）。

##### 硬链接（硬链接，以文件副本的形式存在。但不占用实际空间，不能对目录，只能同一操作系统）

 硬链接是指通过索引节点来进行链接。

在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都会给它分配一个编号，这个编号被称为索引节点编号(Inode Index)或者Inode，**它是文件或者目录在一个文件系统中的唯一标识**，文件的实际数据放置在数据区域（data block），它存储着文件重要参数信息，也就是元数据 （metadata），比如创建时间、修改时间、文件大小、属主、归属的用户组、读写权限、数据所在block号等，

![image-20210912164548216](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912164548216.png)

在Linux系统中，**多个文件名指向同一索引节点(Inode)是正常且允许的。 这一般称为硬链接。**

在Linux系统中，多个文件名指向同一索引节点(Inode)是正常且允许的。 一般这种链接就称为硬链接。 链接的作用之一是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要的文件，以防止“误删”源数据。 不过硬链接只能在同一文件系统中的文件之间进行链接，不能对目录进行创建。

之所以文件建立了硬链接就会防止数据误删，是因为文件系统的原理是，只要文件的索引节点还有一个以上的链接（仅删除了该文件的指向），只删除其中一个链接并不影响索引节点本身和其他的链接（数据的实体并未删除），只有当最后一个链接被删除后，此时如果有新数据要存储到磁盘上，被删除的文件的数据块及目录的链接才会被释放，空间被新数据暂用覆盖。

##### 软链接（存放另一个文件的路径的形式存在，可以跨文件系统，可以对目录）

软链接（也叫符号链接），类似于windows系统中的快捷方式，与硬链接不同，软链接就是一个普通文件，只是数据块内容有点特殊，文件用户数据块中存放的内容是另一文件的路径名的指向，通过这个方式可以快速定位到软连接所指向的源文件实体。

**软链接可对文件或目录创建。**

**便于文件的管理，比如把一个复杂路径下的文件链接到一个简单路径下方便用户访问。**

**节省空间解决空间不足问题，某个文件文件系统空间已经用完了，但是现在必须在该文件系统下创建一个新的目录并存储大量的文件，那么可以把另一个剩余空间较多的文件系统中的目录链接到该文件系统中。**

删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接就变成了死链接。



#### 7.进程管理

##### 1. ps

查看某个时间点的进程信息。

示例：查看自己的进程

```
## ps -l
```

示例：查看系统所有进程

```
## ps aux
```

示例：查看特定的进程

```
## ps aux | grep threadx
```

##### 2. pstree

查看进程树。

示例：查看所有进程树

```
## pstree -A
```

##### 3. top

实时显示进程信息。

示例：两秒钟刷新一次

```
## top -d 2
```

##### 4. netstat

**查看占用端口的进程**

示例：查看特定端口的进程

```
## netstat -anp | grep port
```

![image-20210912171743166](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210912171743166.png)

| 状态 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| R    | running or runnable (on run queue) 正在执行或者可执行，此时进程位于执行队列中。 |
| D    | uninterruptible sleep (usually I/O) 不可中断阻塞，**通常为 IO 阻塞。** |
| S    | interruptible sleep (waiting for an event to complete) 可中断阻塞，**此时进程正在等待某个事件完成。** |
| Z    | zombie (terminated but not reaped by its parent) **僵死，进程已经终止但是尚未被其父进程获取信息。** |
| T    | stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。 |

#### SIGCHLD

当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：

- 得到 SIGCHLD 信号；
- waitpid() 或者 wait() 调用会返回。

其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。

**在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。**

##### wait()

```
pid_t wait(int *status)
```

**父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。**

如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。

**参数 status 用来保存被收集的子进程退出时的一些状态**，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。

##### waitpid()

```
pid_t waitpid(pid_t pid, int *status, int options)
```

作用和 wait() 完全相同，**但是多了两个可由用户控制的参数 pid 和 options。**

pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。**如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。**

options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，**WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。**

##### 孤儿进程

**一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。**

**孤儿进程将被 init 进程（进程号为 1）所收养**，并由 init 进程对它们完成状态收集工作。

由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。

##### 僵尸进程

**一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。**

僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。

系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

**要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。**





# TinyWebserver



### [locker.h 线程同步机制包装类](https://www.jianshu.com/p/4fdad407068b)

##### C++ semaphore信号量的使用

- sem_init()

- ```cpp
  int sem_init(sem_t *sem,int pshared,unsigned int value); 
  ```

> sem_init函数是Posix信号量操作中的函数。sem_init() 初始化一个定位在 sem 的匿名信号量。value 参数指定信号量的初始值。 pshared 参数指明信号量是由进程内线程共享，还是由进程之间共享。如果 pshared 的值为 0，那么信号量将被进程内的线程共享，并且应该放置在这个进程的所有线程都可见的地址上(如全局变量，或者堆上动态分配的变量)。
>
> 如果 pshared 是非零值，那么信号量将在进程之间共享，并且应该定位共享内存区域(见 shm_open(3)、mmap(2) 和 shmget(2))。因为通过 fork(2) 创建的孩子继承其父亲的内存映射，因此它也可以见到这个信号量。所有可以访问共享内存区域的进程都可以用 sem_post(3)、sem_wait(3) 等等操作信号量。初始化一个已经初始的信号量其结果未定义。

- sem_init函数用于初始化一个未命名的信号量
- sem_destory函数用于销毁信号量
- sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞
- sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程

##### **互斥量**

- 互斥锁,也成互斥量,可以保护关键代码段,以确保独占式访问.当进入关键代码段,获得互斥锁将其加锁;离开关键代码段,唤醒等待该互斥锁的线程.

- pthread_mutex_init函数用于初始化互斥锁
- pthread_mutex_destory函数用于销毁互斥锁
- pthread_mutex_lock函数以原子操作方式给互斥锁加锁
- pthread_mutex_unlock函数以原子操作方式给互斥锁解锁

##### **条件变量**

条件变量提供了一种线程间的通知机制,**当某个共享数据达到某个值时,唤醒等待这个共享数据的线程**.

- pthread_cond_init函数用于初始化条件变量
- pthread_cond_destory函数销毁条件变量
- pthread_cond_broadcast函数以广播的方式唤醒**所有**等待目标条件变量的线程
- pthread_cond_wait函数用于等待目标条件变量.该函数调用时需要传入 **mutex参数(加锁的互斥锁)** ,函数执行时,先把调用线程放入条件变量的请求队列,然后将互斥锁mutex解锁,当函数成功返回为0时,互斥锁会再次被锁上. **也就是说函数内部会有一次解锁和加锁操作**.

> 条件变量是用来等待线程而不是上锁的，条件变量通常和互斥锁一起使用。条件变量之所以要和互斥锁一起使用，主要是因为互斥锁的一个明显的特点就是它只有两种状态：锁定和非锁定，而条件变量可以通过允许线程阻塞和等待另一个线程发送信号来弥补互斥锁的不足，所以互斥锁和条件变量通常一起使用。
>
> 当条件满足的时候，线程通常解锁并等待该条件发生变化，一旦另一个线程修改了环境变量，就会通知相应的环境变量唤醒一个或者多个被这个条件变量阻塞的线程。这些被唤醒的线程将重新上锁，并测试条件是否满足。一般来说条件变量被用于线程间的同步；当条件不满足的时候，允许其中的一个执行流挂起和等待。
>
> 简而言之，条件变量本身不是锁，但它也可以造成线程阻塞，通常与互斥锁配合使用，给多线程提供一个会合的场所。

所以可以看出pthread_join()有两种作用：

用于等待其他线程结束：当调用 pthread_join() 时，当前线程会处于阻塞状态，直到被调用的线程结束后，当前线程才会重新开始执行。
对线程的资源进行回收：如果一个线程是非分离的（默认情况下创建的线程都是非分离）并且没有对该线程使用 pthread_join() 的话，该线程结束后并不会释放其内存空间，这会导致该线程变成了“僵尸线程”。





### 半同步/半反应堆线程池

使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。

> - 同步I/O模拟proactor模式
> - 半同步/半反应堆
> - 线程池

#### 服务器编程基本框架

主要由I/O单元，逻辑单元和网络存储单元组成，其中每个单元之间通过请求队列进行通信，从而协同完成任务。

其中I/O单元用于处理客户端连接，读写网络数据；逻辑单元用于处理业务逻辑的线程；网络存储单元指本地数据库和文件等。

![image-20210826120804513](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210826120804513.png)

#### 事件处理模式

- reactor模式中，主线程(**I/O处理单元**)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(**逻辑单元** )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由**同步I/O**实现。
- proactor模式中，主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由**异步I/O**实现。

#### **pthread_create陷阱**

```C++
#include <pthread.h>
int pthread_create (pthread_t *thread_tid,                 //返回新生成的线程的id
                    const pthread_attr_t *attr,   //指向线程属性的指针,通常设置为NULL
                    void * (*start_routine) (void *),   //处理线程函数的地址
                   void *arg);                         //start_routine()中的参数
```

> 函数原型中的第三个参数，为函数指针，指向处理线程函数的地址。该函数，要求为静态函数。如果处理线程函数为类成员函数时，需要将其设置为**静态成员函数**。
>
> pthread_create的函数原型中第三个参数的类型为函数指针，指向的线程处理函数参数类型为`(void *)`,若线程函数为类成员函数，**则this指针会作为默认的参数被传进函数中，从而和线程函数参数`(void*)`不能匹配，不能通过编译。**  静态成员函数就没有这个问题，里面没有this指针。
>
> 

构造函数中创建线程池,pthread_create函数中将类的对象作为参数传递给静态函数(worker),在静态函数中引用这个对象,并调用其动态方法(run)。

具体的，类对象传递时用this指针，传递给静态函数后，将其转换为线程池类，并调用私有成员函数run。

```c++
   //循环创建线程，并将工作线程按要求进行运行
  if(pthread_create(m_threads+i,NULL,worker,this)!=0){
     delete [] m_threads;
    throw std::exception();
    }
```

##### 线程分离相关

Linux系统中程序的线程资源是有限的，表现为对于一个程序其能同时运行的线程数是有限的。而默认的条件下，一个线程结束后，其对应的资源不会被释放，于是，如果在一个程序中，反复建立线程，而线程又默认的退出，则最终线程资源耗尽，进程将不再能建立新的线程。

- 解决这个问题，有2种方式，系统自动释放线程资源，或者由另一个线程释放该线程资源。

- 进程运行后，本身，也是一个线程，主线程，主线程和主线程建立的线程共享进程资源。不同于其他线程，在于主线程运行结束后，程序退出，所有程序建立的线程也会退出

如果想在线程结束时，由系统释放线程资源，则需要设置线程属性为detach，使线程分离主线程

linux线程执行和windows不同，pthread有两种状态joinable状态和unjoinable状态**，如果线程是joinable状态，当线程函数自己返回退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符**（总计8K多）。只有当你调用了pthread_join之后这些资源才会被释放。
若是unjoinable状态的线程，这些资源在线程函数退出时或pthread_exit时自动会被释放。

unjoinable属性可以在pthread_create时指定，或在线程创建后在线程中pthread_detach自己,如：pthread_detach(pthread_self())，将状态改为unjoinable状态，确保资源的释放。或者将线程置为joinable,然后适时调用pthread_join.



还有2个函数可以实现线程的分离，pthread_detach(threadid)和pthread_detach(pthread_self())。

这2个函数区别是调用他们的线程不同，没其他区别。

pthread_detach(threadid)函数的功能是使线程ID为threadid的线程处于分离状态，一旦线程处于分离状态，该线程终止时底层资源立即被回收；否则终止子线程的状态会一直保存（占用系统资源）直到主线程调用pthread_join(threadid,NULL)获取线程的退出状态。
通常是主线程使用pthread_create()创建子线程以后，一般可以调用pthread_detach(threadid)分离刚刚创建的子线程，这里的threadid是指子线程的threadid；如此以来，该子线程止时底层资源立即被回收；
被创建的子线程也可以自己分离自己，子线程调用pthread_detach(pthread_self())就是分离自己，因为pthread_self()这个函数返回的就是自己本身的线程ID。



### http连接处理

#### **select/poll/epoll**

- 调用函数

- - select和poll都是一个函数，epoll是一组函数

- 文件描述符数量

- - select通过**线性表描述文件描述符集合**，文件描述符有上限，一般是1024，但可以修改源码，重新编译内核，不推荐
  - **poll是链表描述，**突破了文件描述符上限，最大可以打开文件的数目
  - epoll通过红黑树描述，最大可以打开文件的数目，可以通过命令ulimit -n number修改，仅对当前终端有效

- 将文件描述符从用户传给内核

- - **select和poll通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝**
  - epoll通过epoll_create**建立一棵红黑树**，通过**epoll_ctl将要监听的文件描述符注册到红黑树上**

- 内核判断就绪的文件描述符

- - select和poll通过遍历文件描述符集合，判断哪个文件描述符上有事件发生
  - epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个**list链表**，用于**存储准备就绪的事件**，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。
  - **epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list**

- 应用程序索引就绪文件描述符

- - select/poll只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历
  - epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可

- 工作模式

- - select和poll都只能工作在相对低效的LT模式下
  - epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。 

- 应用场景

- - 当所有的fd都是活跃连接，使用epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如selece和poll
  - 当监测的fd数目较小，且各个fd都比较活跃，建议使用select或者poll
  - 当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能

### readv()和writev()函数

- read()和write()系统调用**每次在文件和进程的地址空间之间传送一块连续的数据**。但是，应用有时也需要将分散在内存多处地方的数据连续写到文件中，或者反之。在这种情况下，**如果要从文件中读一片连续的数据至进程的不同区域，**使用read()则要么一次将它们读至一个较大的缓冲区中，然后将它们分成若干部分复制到不同的区域，要么调用read()若干次分批将它们读至不同区域。同样，如果想将程序中不同区域的数据块连续地写至文件，也必须进行类似的处理。

  **UNIX提供了另外两个函数—readv()和writev()，它们只需一次系统调用就可以实现在文件和进程的多个缓冲区之间传送数据，**免除了多次系统调用或复制数据的开销。**readv()称为散布读，即将文件中若干连续的数据块读入内存分散的缓冲区中。writev()称为聚集写，即收集内存中分散的若干缓冲区中的数据写至文件的连续区域中。**

![img](http://www.2cto.com/uploadfile/2012/1219/20121219031549963.jpg)

> 图3-4说明了参数iovcnt、iov及其所指数组与这两个函数的关系。writev()依次将iov[0]、iov[1]、...、 iov[iovcnt–1]指定的存储区中的数据写至fildes指定的文件。writev()的返回值是写出的数据总字节数，正常情况下它应当等于所有数据块长度之和。
>
> eadv()则将fildes指定文件中的数据按iov[0]、iov[1]、...、iov[iovcnt–1]规定的顺序和长度，分散地读到它们指定的存储地址中。readv()的返回值是读入的总字节数。如果没有数据可读和遇到了文件尾，其返回值为0。
>
> 有了这两个函数，当想要集中写出某张链表时，只需让iov数组的各个元素包含链表中各个表项的地址和其长度，然后将iov和它的元素个数作为参数传递给writev()，这些数据便可一次写出。

iov是一个结构数组，它的每个元素指明存储器中的一个缓冲区。结构类型iovec有下述成员，分别给出缓冲区的起始地址和字节数：

### mmap函数

UNIX网络编程第二卷进程间通信对mmap函数进行了说明。该函数主要用途有三个：
1、将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I/O读写，以获得较高的性能；
2、将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间；
3、为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。

### 定时器处理非活动连接

`定时事件`，是指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源。

`定时器`，是指利用结构体或其他形式，将多种定时事件进行封装起来。具体的，这里只涉及一种定时事件，即定期检测非活跃连接，这里将该定时事件与连接资源封装为一个结构体定时器。

`定时器容器`，是指使用某种容器类数据结构，将上述多个定时器组合起来，便于对定时事件统一管理。具体的，项目中使用升序链表将所有定时器串联组织起来。



本项目中，服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时。另外，利用升序时间链表容器将所有定时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务。

`Linux`下提供了三种定时的方法:

- socket选项SO_RECVTIMEO和SO_SNDTIMEO
- SIGALRM信号
- I/O复用系统调用的超时参数

三种方法没有一劳永逸的应用场景，也没有绝对的优劣。由于项目中使用的是`SIGALRM`信号，这里仅对其进行介绍，另外两种方法可以查阅游双的`Linux高性能服务器编程 第11章 定时器`。

具体的，利用`alarm`函数周期性地触发`SIGALRM`信号，信号处理函数利用管道通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源。

从上面的简要描述中，可以看出定时器处理非活动连接模块，主要分为两部分，其一为**定时方法与信号通知流程**，其二为**定时器及其容器设计与定时任务的处理。**

socketpair和管道形式非常的类似，唯一的不同就是sockerpair支持全双工，这样在进程之间发送数据的时候变得非常的简单方便。

### API介绍

管道pipe是半双工的，pipe两次才能实现全双工，使得代码复杂。socketpair直接就可以实现全双工

### [Linux系统下进程的信号处理流程](https://www.jianshu.com/p/4fd8e35a6580)







### 日志系统

本项目中，使用单例模式创建日志系统，对服务器运行状态、错误信息和访问数据进行记录，该系统可以实现按天分类，超行分类功能，可以根据实际情况分别使用同步和异步写入两种方式。

其中异步写入方式，将生产者-消费者模型封装为阻塞队列，创建一个写线程，工作线程将要写的内容push进队列，写线程从队列中取出内容，写入日志文件。

日志系统大致可以分成两部分，其一是单例模式与阻塞队列的定义，其二是日志类的定义与使用。

##### 单例模式

- 单例模式作为最常用的设计模式之一，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。

- 实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。

- 单例模式有两种实现方法，分别是懒汉和饿汉模式。顾名思义，懒汉模式，即非常懒，不用的时候不去初始化，所以在第一次被使用时才进行初始化；饿汉模式，即迫不及待，在程序运行时立即初始化。

###### **经典的线程安全懒汉模式**，使用双检测缩模式

```c++
pthread_mutex_t single::lock;

single* single::p = NULL;
single* single::getinstance(){
    if (NULL == p){
        pthread_mutex_lock(&lock);
        if (NULL == p){
            p = new single();
        }
        pthread_mutex_unlock(&lock);
    }
    return p;
```

**`为什么要用双检测，只检测一次不行吗？`**

如果只检测一次，在每次调用获取实例的方法时，都需要加锁，这将严重影响程序性能。双层检测可以有效避免这种情况，仅在第一次创建单例的时候加锁，其他时候都不再符合NULL == p的情况，直接返回已创建好的实例。

前面的双检测锁模式，写起来不太优雅，《Effective C++》（Item 04）中的提出另一种更优雅的单例模式实现，使用函数内的局部静态对象，这种方法不用加锁和解锁操作。

```c++
 class single{
 private:
     single(){}
     ~single(){}
 
 public:
     static single* getinstance();
 
 };

single* single::getinstance(){
    static single obj;
    return &obj;
}
```

其实，C++0X以后，**要求编译器保证内部静态变量的线程安全性**，故C++0x之后该实现是线程安全的，C++0x之前仍需加锁，其中C++0x是C++11标准成为正式标准之前的草案临时名字。

所以，如果使用C++11之前的标准，还是需要加锁，这里同样给出加锁的版本。

#### **饿汉模式**，线程安全，不要加锁

- 不需要锁就可以实现线程安全。原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁
- 饿汉模式虽好，但其存在隐藏的问题，**在于非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。**如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。

![image-20210827224922643](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210827224922643.png)







![image-20210903125206379](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210903125206379.png)

![image-20210903125219816](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210903125219816.png)

Reactor

![image-20210903142910679](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210903142910679.png)

![image-20210903143004703](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210903143004703.png)







### 问题整理

#### GET和POST比较

- GET 用于获取资源，而 POST 用于传输实体主体。
- GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。
- 因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 `中文` 会转换为 `%E4%B8%AD%E6%96%87`，而空格会转换为 `%20`。POST 参数支持标准字符集。

`GET /test/demo_form.asp?name1=value1&name2=value2 HTTP/1.1`

```
POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&name2=value2
```

- GET产生一个TCP数据包；**POST产生两个TCP数据包**。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100（指示信息—表示请求已接收，继续处理）continue，浏览器再发送data，服务器响应200 ok（返回数据）。

##### 安全

安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。

GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。

#### HTTPS

##### HTTP 有以下安全性问题：

- 使用明文进行通信，内容可能会被窃听；
- 不验证通信方的身份，通信方的身份有可能遭遇伪装；
- 无法证明报文的完整性，报文有可能遭篡改。

HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。

通过使用 SSL，HTTPS 具有了加密（防窃听）（加密保证私密性）、认证（防伪装）（通过对证书的认证）和完整性保护（防篡改）。（数字签名保证完整性）

![img](https://camo.githubusercontent.com/d742fcbc48d96d10aeb1996c62410acac607e421adb44cc544105f1f84c3b284/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f73736c2d6f66666c6f6164696e672e6a7067)



##### HTTPS 采用的加密方式

上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：

- 使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;
- 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）

##### 认证

通过使用 **证书** 来对通信方进行认证。

**证书实际上就是对公钥进行数字签名，它是对公钥合法性提供证明的技术。**(对证书进行签名)

证书就如身份证，证明“该公钥对应该网站”

> 接下来又有问题了：验证证书中的数字签名需要另一个公钥，那么这个公钥的合法性又该如何保证？该问题可以无限循环下去，岂不是到不了头了？这已经是个社会学问题了。我们为什么把钱存进银行？因为我们相信银行，它是一个可信的机构（虽然也有破产的风险）。跟银行一样，我们需要一个可信的机构来颁发证书和提供公钥，只要是它提供的公钥，我们就相信是合法的。

> 这种机构称为认证机构(Certification Authority， CA)。CA就是能够认定”公钥确实属于此人”，并能生成公钥的数字签名的组织或机构。CA有国际性组织和政府设立的组织，也有通过提供认证服务来盈利的组织。
>
> 





**数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。**

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

##### 证书有哪些内容

- 证书有：证书所有人的公钥，网站地址，证书的颁发机构，失效日期，证书发行者对证书的签名，（指纹）数字签名所使用的算法。（指纹算法）

##### 如何生成证书？

1. 服务器将公钥A给CA（公钥是服务器的）
2. CA用自己的私钥B给公钥A加密，生成数字签名A
3. CA把公钥A，数字签名A，附加一些服务器信息整合在一起，生成证书，发回给服务器。

注：私钥B是用于加密公钥A的，私钥B和公钥A并不是配对的。

##### 如何验证证书？

1. 客户端得到证书
2. 客户端得到证书的公钥B（通过CA或其它途径）
3. 客户端用公钥B对证书中的数字签名解密，得到哈希值
4. 客户端对公钥进行哈希值计算
5. 两个哈希值对比，如果相同，则证书合法。

注：公钥B和上述的私钥B是配对的，分别用于对证书的验证（解密）和生成（加密）

#### 长连接与短连接

当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。

长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。

- 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 `Connection : close`；
- 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 `Connection : Keep-Alive`。

#### Cookie

HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。

Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。

#### 1. 用途

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）







#### 1. 同步I/O 与 异步I/O

![image-20210914020212557](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210914020212557.png)



![image-20210914020405302](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210914020405302.png)

![image-20210914020518419](C:\Users\17836\AppData\Roaming\Typora\typora-user-images\image-20210914020518419.png)

#### 2.线程池的优势

总得来说，使用线程池可以带来以下几个好处：

1. 降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。
2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
3. 增加线程的可管理型。线程是稀缺资源，使用线程池可以进行统一分配，调优和监控。
