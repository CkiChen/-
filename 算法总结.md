算法总结

[toc]

## 组合和排序

- 首先明确是组合 还是排序 组合需要startIndex

- 其次明确是否去重,若要去重，先排序，使相同的元素挨着

- 明确是树层间去重（used[i-1] == false）(某个位置元素不重复出现在各个答案中)，还是树枝上的去重(used[i-1] == true)（一个答案中没有相同的数字）
-  if (used[i] == false){  } 用于排除自己，看需要而选择，一般组合问题不需要，因为组合问题从每次下一个位置开始遍历，而排列问题需要从头开始遍历，而且不便利自己。

```C++
//关键代码  
//同树层剪枝
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
    continue;
}
//同树枝剪枝
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == true) {
    continue;
}
```

#### leetcode 40 组合总和 Ⅱ

```C++
class Solution {
    vector<vector<int>> ans;
    vector<int> path;
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        int n = candidates.size();
        sort(candidates.begin(),candidates.end());
        vector<int> used(n,0);
        int sum = 0;
        dfs(candidates,target,used,0,0);  //组合问题，需要startIndex。
        return ans;
    }
    void dfs(vector<int>& candidates, int target, vector<int> &used,int startIndex,int sum){
        int n = candidates.size();
        if(sum > target) return;
        if(sum == target){
            ans.push_back(path);
            return;
        }

        for(int i = startIndex; i < n; ++i){
            //去重,因为每个数字只能在组合中使用一次，所以要进行树层的去重
            if(i > 0 && candidates[i] == candidates[i-1] && used[i-1] == 0){
                continue;
            }
                used[i] = 1;
                sum += candidates[i];
                path.push_back(candidates[i]);
                dfs(candidates,target,used,i + 1,sum);
                path.pop_back();
                sum -= candidates[i];
                used[i] = 0;
        }
    }
};
```

#### leetcode 90 子集Ⅱ

#### leetcode 46 全排列

#### 剑指 Offer 38. 字符串的排列





## 背包问题

容量W的背包，N个物品   第i个物品的体积为w[i],  价值为v[i].

状态：容量会变，物品可选在变（变化的 量为状态）

选择：装入，或不装入背包

##### 01背包

外循环遍历arrs（可选的物品列表），内循环遍历target，且内循环倒叙。    （即能否用arrs中的元素做各种排列组合得到target）。

##### 完全背包（一个元素可以用多次）

1.不考虑元素顺序（组合问题）：外循环遍历arrs，内循环遍历target，且内循环正序。

2.考虑元素顺序（排列问题）：外循环target，内循环arrs，且内循环正序。

##### 多重背包（不止一个背包，需要遍历每个背包）

这个比较特殊，需要三重循环：外循环背包bags,内部两层循环根据题目的要求转化为1,2,3三种背包类型的模板



而每个背包问题要求的也是不同的，按照所求问题分类，又可以分为以下几种：

1、最值问题：要求最大值/最小值                                       dp[i] = max/min(dp[i], dp[i-nums]+1)或dp[i] = max/min(dp[i], dp[i-num]+nums);
2、存在问题：是否存在…………，满足…………               (bool)：dp[i]=dp[i] || dp[i-num];           一般初始化为true
3、组合问题：求所有满足……的排列组合                          dp[i]+=dp[i-num];                                一般初始化为1

###### leetcode 416

```C++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int N = nums.size();
        int V = accumulate(nums.begin(),nums.end(),0);
          if (V % 2 != 0) 
          {
        return false;
        }
        V = V / 2;
        vector<int> dp(V+1,0);
        dp[0] = 1;
        for(int i = 1; i <= N; ++i){
            int v = nums[i-1];
            for(int j = V; j >= v; --j){
                dp[j] = dp[j] || dp[j-v];
            }
        }
            return dp[V];
    }
};
```





## 大、小堆(解决TopK 问题)

```C++
/*定义：priority_queue<Type, Container, Functional>
Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆*/

//升序队列(小顶堆)
priority_queue <int,vector<int>,greater<int> > q;
//降序队列(大顶堆)
priority_queue <int,vector<int>,less<int> >q;


//对于基础类型 默认是大顶堆
 priority_queue<int> a; 
//等同于 priority_queue<int, vector<int>, less<int> > a;


//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）
```



## BFS

网格结构的与二叉树的最大的不同之处在于，遍历中可能遇到遍历过的结点。

> 1.确定state结构体，用于记录一些变化的信息，构造queue<state> 队列以进行BFS
>
> ```C++
> //整体框架如下
> vvector<bool>  //vis 的定义，用于剪枝遍历过的区域，记住要赋值0， 
>     //或者 定义 bool vis【maxn】【maxn】 然后memset(vis,0,sizeof vis);
> queue<state> q;
> q.push({});     // 初始值
> while(!q.empty()){
>     int n = q.size();
>     while(n--){
>         auto f = q.front();
>         q.pop();
>         for(int i = 0; i < 4; ++i){         //搜索区间的遍历
>             x = q.x + dx[i];
>             y = q.y + dy[i];
>             .......
>         }
>               }
> }
> ```
>
> 

#### leetcode  1162 地图分析

> 我们需不需要搜索到队列为空才停止 BFS ？ 答案是不需要。当我们搜索到一个新入队的区域它的 grid 值为 1，即这个区域是陆地区域的时候我们就可以停止搜索，因为 BFS 能保证当前的这个区域是最近的陆地区域（BFS 的性质决定了这里求出来的一定是最短路）



#### 动态规划

###### leetcode 516 最长回文子序列

```C++
 for (int i = 0; i < n; i++) dp[i][i] = 1;
        for(int i = n - 1; i >= 0; --i){
            for(int j = i + 1; j < n; ++j){
                if(s[i] == s[j])  dp[i][j] = dp[i + 1][j - 1] + 2;
                else dp[i][j] = max(dp[i+1][j],dp[i][j-1]);
            }
        }
```

###### leetcode 300 最长递增子序列

```C++
for (int i = 0; i < n; ++i) {
            dp[i] = 1;
            for (int j = 0; j < i; ++j) {
                if (nums[j] < nums[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        
```

###### leetcode 1143 最长公共子序列

```C++
for(int i = 1; i <= m; ++i){
            for(int j = 1; j <= n; ++j){
                if(text1[i-1] == text2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;
                else{
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
```

## 

## 滑动窗口技巧

#### 模板

```C++
int left = 0, right = 0;

while (right < s.size()) {
    window.add(s[right]);
    right++;
    
    while (valid) {
        window.remove(s[left]);
        left++;
    }
}
```

需要注意的是，因为我们要求的是最长子串，所以需要在每次移动 right 增大窗口时更新 res，而不是像之前的题目在移动 left 缩小窗口时更新 res。 就是要注意更新res的位置。

#### leetcode76 最小覆盖子串

```C++
class Solution {
public:
    string minWindow(string s, string t) {
        int start= 0, minLen = INT_MAX;          //记录开始位置和最小长度用substr就可以切割字符串
        int left = 0, right = 0;
        unordered_map<char,int> need;
        unordered_map<char,int> window; 

        int match = 0;  //记录匹配了的个数，够了就移动左指针

        for(auto tt:t){
            need[tt]++;
        }

        while(right < s.size()){              //退出条件
            char c1 = s[right];
            if(need.count(c1)){
                window[c1]++;
                if(need[c1] == window[c1]){
                    match++;
                }
            }
            right++;

            while(match == need.size()){   //这里开始移动左指针
          //此处是need.size(),因为t中会存在重复的字符，need中会就行合并，我们match是need中匹配的字符个数。
             if (right - left < minLen) {
                // 更新最小子串的位置和长度
                start = left;
                minLen = right - left;
            }

                char c2 = s[left];
                if(need.count(c2)){
                    window[c2]--;
                    if(window[c2] < need[c2]){
                        match--;
                    }
                }
                left++;
            }
        }
        return minLen == INT_MAX? "":s.substr(start,minLen);
    }
};
```





## 二叉树相关

​		**如果需要搜索整颗二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。**

**递归三部曲： 终止条件是什么，每一级需要返回什么，单步操作需要做什么怎么写（每一步只有root，root->left和root->right）**

#### 路径总和

```C++
if (cur->left) { // 左 （空节点不遍历）
    // 遇到叶子节点返回true，则直接返回true
    if (traversal(cur->left, count - cur->left->val)) return true; // 注意这里有回溯的逻辑
}
if (cur->right) { // 右 （空节点不遍历）
    // 遇到叶子节点返回true，则直接返回true
    if (traversal(cur->right, count - cur->right->val)) return true; // 注意这里有回溯的逻辑
}
```

以上代码中是包含着回溯的，没有回溯，如何后撤重新找另一条路径呢。

回溯隐藏在`traversal(cur->left, count - cur->left->val)`这里， 因为把`count - cur->left->val` 直接作为参数传进去，函数结束，count的数值没有改变。

为了把回溯的过程体现出来，可以改为如下代码：

```C++
if (cur->left) { // 左
    count -= cur->left->val; // 递归，处理节点;
    if (traversal(cur->left, count)) return true;
    count += cur->left->val; // 回溯，撤销处理结果
}
if (cur->right) { // 右
    count -= cur->right->val;
    if (traversal(cur->right, count)) return true;
    count += cur->right->val;
}
return false;
```

#### 路径总和Ⅱ

```C++
class Solution {
    vector<vector<int>> ans;
    vector<int> path;
public:
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if(root == NULL) return ans;
        path.push_back(root->val);
        dfs(root,targetSum - root->val);
        return ans;
    }
    void dfs(TreeNode* root, int targetSum){
        if(!root->left && !root->right && targetSum == 0){
            ans.push_back(path);
        }
        if(!root->left && !root->right) return;

        if(root->left){
            path.push_back(root->left->val);               //回溯
            dfs(root->left,targetSum - root->left->val);   //递归里带回溯
            path.pop_back();                               //回溯
        }

        if(root->right){
            path.push_back(root->right->val);
            dfs(root->right,targetSum - root->right->val);
            path.pop_back();
        }

    }
};
```

#### 同统一写法的迭代版遍历

```C++
//迭代实现
//此处背诵通用写法 1.null不入栈   2.if(node) 后要先pop() node 因为后面还会按照顺序入栈，前面只是为了引入它的左右结点       3.中间结点node入栈后再压入一个null   4. 不遇到null，不将栈中元素压入结果集
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        stack<TreeNode*> st;
        if(root) st.push(root);
        while(!st.empty()){
            TreeNode* node = st.top();
            if(node){
                st.pop();       //弹出避免重复操作
                //下面开始按照遍历的顺序的相反顺序来，中序 正常 左中右， 迭代：右中左
                if(node->right) st.push(node->right);
                st.push(node);
                st.push(NULL);          //做标记

                if(node->left) st.push(node->left);
            }
            else{
                st.pop();        //弹出空结点
                node = st.top();
                st.pop();
                ans.push_back(node->val);
            }
        }
        return ans;
    }
};
```

#### leetcode 110 平衡二叉树

https://lyl0724.github.io/2020/01/25/1/#vcomment 递归教学文

```C++
class Solution {
public:
    int height(TreeNode* root) {
        if (root == NULL) {
            return 0;
        } else {
            return max(height(root->left), height(root->right)) + 1;
        }
    }

    bool isBalanced(TreeNode* root) {
        if (root == NULL) {
            return true;
        } else {
            return abs(height(root->left) - height(root->right)) <= 1 && isBalanced(root->left) && isBalanced(root->right);
        }
    }
};
```







## 单调队列

```C++
    class myquue{
        public: 
            deque<int> dq;
            void pop(int val){
                if(!dq.empty() && val == dq.front()){
                    dq.pop_front();
                }
            }

            void push(int val){
                while(!dq.empty() && val > dq.back()){
                    dq.pop_back();
                }
                dq.push_back(val);
            }

            int front(){
                return dq.front();
            }
    };
```

#### 剑指offer59  滑动窗口的最大值

```C++
class Solution {
public:
    class MyQueue{
        public: 
            deque<int> dq;
            void pop(int val){
                if(!dq.empty() && val == dq.front()){
                    dq.pop_front();
                }
            }

            void push(int val){
                while(!dq.empty() && val > dq.back()){
                    dq.pop_back();
                }
                dq.push_back(val);
            }

            int front(){
                return dq.front();
            }
    };

    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MyQueue que;
        vector<int> result;
        if (nums.empty()) {
            return result;
        }
        for (int i = 0; i < k; i++) { // 先将前k的元素放进队列
            que.push(nums[i]);
        }
        result.push_back(que.front()); // result 记录前k的元素的最大值
        for (int i = k; i < nums.size(); i++) {
            que.pop(nums[i - k]); // 模拟滑动窗口的移动
            que.push(nums[i]); // 模拟滑动窗口的移动
            result.push_back(que.front()); // 记录对应的最大值
        }
        return result;
    }
};
```

## KMP

next 存字串最长相等前后缀长度

i 后缀根  遍历

j 前缀根，字串最长相等前后缀的长度    

### leetcode 459 重复的子字符串

> 如果len % (len - (next[len - 1] + 1)) == 0 ，则说明 (数组长度-最长相等前后缀的长度) 正好可以被 数组的长度整除，说明有该字符串有重复的子字符串。
>
> **数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。**

```C++
class Solution {
public:
    void getNext(int * next, const string &s){                //next数组的求法
            int j = 0;
            next[0] = 0;
            for(int i = 1; i < s.size(); ++i){            //此处从1开始！！！！！！
                while(j > 0 && s[i] != s[j]){          //不匹配一直向前回退
                    j = next[j-1];                    //回退到next【n-1】 指向的位置，也就是有相等前后缀的位置
                }
                if(s[i] == s[j]) j++;                 //相等 j就++
                next[i] = j;                          //最后把j的值赋值给next【i】
            }
    }

    bool repeatedSubstringPattern(string s) {
        if (s.size() == 0) {
            return false;
        }
        int n = s.size();
        int next[n];
        getNext(next,s);
        for(int i = 0; i < n; ++i){
            cout<<next[i]<<endl;
        }
        if (next[n - 1] != 0 && n % (n - (next[n - 1] )) == 0) {
            return true;
        }
        return false;

    }
};
```

#### leetcode 28 实现substr

```C++
class Solution {
    void getNext(int *next, const string &s){
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); ++i){
            while(j > 0 && s[i] != s[j]){
                j = next[j-1];
            }
            if(s[i] == s[j]) j++;
            next[i] = j;
        }
    }

public:
    int strStr(string haystack, string needle) {
       int n = needle.size();
       if(!n) return 0;
       int next[n];
       getNext(next, needle);
       int j = 0;
       for (int i = 0; i < haystack.size(); i++) {
            while(j > 0 && haystack[i] != needle[j]) {
                j = next[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            if (j == needle.size() ) {
                return (i - needle.size() + 1);
            }
       }
        return -1;
    }
};



//暴力法
class Solution {
public:
    int strStr(string haystack, string needle) {
        int n = haystack.size(), m = needle.size();
        for (int i = 0; i + m <= n; i++) {    //循环i表示的是hay起始的位置，往后面找j个 全相等才算。不能两层循环两个字符串
            bool flag = true;
            for (int j = 0; j < m; j++) {
                if (haystack[i + j] != needle[j]) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                return i;
            }
        }
        return -1;
    }
};

```















## sort和priority_queue 中重写比较函数的方法

#### sort

##### 1.重载操作符（重载类的比较运算符）

```C++
bool operator<(const stu &p)const
    {
        return age<p.age;
    }

sort(num,num+n);
```

##### 2.自定义cmp函数（声明外部比较函数）

注意：比较函数必须写在**类外部（全局区域）或声明为静态函数**

```C++
 static bool cmp(const stu &q,const stu &p)
{
    return q.num<p.num;
}

sort(num,num+n,cmp);
```

##### 3.自定义仿函数（声明比较类）

```C++

struct cmp
{
    bool operator ()(const stu &q,const stu &p)
    {
        return q.num>p.num;
    }
};


    sort(S,S+5,cmp());
```

#### priority_queue

##### 1.重载小于操作符

```C++
bool operator<(const stu &p)const
    {
        return age>p.age;
    }
```



##### 2.自定义仿函数

```C++
struct cmp
{
    bool operator ()(const stu &q,const stu &p)
    {
        return q.num<p.num;
    }
};


    priority_queue<stu,vector<stu>,cmp >q;  //不加括号

```











